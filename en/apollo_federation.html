<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Apollo Federation - Async-graphql Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Async-graphql Book">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="typesystem.html"><strong aria-hidden="true">3.</strong> Type System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="define_simple_object.html"><strong aria-hidden="true">3.1.</strong> SimpleObject</a></li><li class="chapter-item expanded "><a href="define_complex_object.html"><strong aria-hidden="true">3.2.</strong> Object</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="context.html"><strong aria-hidden="true">3.2.1.</strong> Context</a></li><li class="chapter-item expanded "><a href="error_handling.html"><strong aria-hidden="true">3.2.2.</strong> Error handling</a></li><li class="chapter-item expanded "><a href="merging_objects.html"><strong aria-hidden="true">3.2.3.</strong> Merging Objects / Subscriptions</a></li><li class="chapter-item expanded "><a href="derived_fields.html"><strong aria-hidden="true">3.2.4.</strong> Derived fields</a></li></ol></li><li class="chapter-item expanded "><a href="define_enum.html"><strong aria-hidden="true">3.3.</strong> Enum</a></li><li class="chapter-item expanded "><a href="define_interface.html"><strong aria-hidden="true">3.4.</strong> Interface</a></li><li class="chapter-item expanded "><a href="define_union.html"><strong aria-hidden="true">3.5.</strong> Union</a></li><li class="chapter-item expanded "><a href="define_input_object.html"><strong aria-hidden="true">3.6.</strong> InputObject</a></li><li class="chapter-item expanded "><a href="define_one_of_object.html"><strong aria-hidden="true">3.7.</strong> OneofObject</a></li><li class="chapter-item expanded "><a href="default_value.html"><strong aria-hidden="true">3.8.</strong> Default value</a></li></ol></li><li class="chapter-item expanded "><a href="define_schema.html"><strong aria-hidden="true">4.</strong> Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="query_and_mutation.html"><strong aria-hidden="true">4.1.</strong> Query and Mutation</a></li><li class="chapter-item expanded "><a href="subscription.html"><strong aria-hidden="true">4.2.</strong> Subscription</a></li><li class="chapter-item expanded "><a href="sdl_export.html"><strong aria-hidden="true">4.3.</strong> SDL Export</a></li></ol></li><li class="chapter-item expanded "><a href="utilities.html"><strong aria-hidden="true">5.</strong> Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="field_guard.html"><strong aria-hidden="true">5.1.</strong> Field guard</a></li><li class="chapter-item expanded "><a href="input_value_validators.html"><strong aria-hidden="true">5.2.</strong> Input value validators</a></li><li class="chapter-item expanded "><a href="cache_control.html"><strong aria-hidden="true">5.3.</strong> Cache control</a></li><li class="chapter-item expanded "><a href="cursor_connections.html"><strong aria-hidden="true">5.4.</strong> Cursor connections</a></li><li class="chapter-item expanded "><a href="error_extensions.html"><strong aria-hidden="true">5.5.</strong> Error extensions</a></li><li class="chapter-item expanded "><a href="apollo_tracing.html"><strong aria-hidden="true">5.6.</strong> Apollo Tracing</a></li><li class="chapter-item expanded "><a href="depth_and_complexity.html"><strong aria-hidden="true">5.7.</strong> Query complexity and depth</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.8.</strong> Hide content in introspection</a></li></ol></li><li class="chapter-item expanded "><a href="extensions.html"><strong aria-hidden="true">6.</strong> Extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="extensions_inner_working.html"><strong aria-hidden="true">6.1.</strong> How extensions are working</a></li><li class="chapter-item expanded "><a href="extensions_available.html"><strong aria-hidden="true">6.2.</strong> Available extensions</a></li></ol></li><li class="chapter-item expanded "><a href="integrations.html"><strong aria-hidden="true">7.</strong> Integrations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrations_to_poem.html"><strong aria-hidden="true">7.1.</strong> Poem</a></li><li class="chapter-item expanded "><a href="integrations_to_warp.html"><strong aria-hidden="true">7.2.</strong> Warp</a></li><li class="chapter-item expanded "><a href="integrations_to_actix_web.html"><strong aria-hidden="true">7.3.</strong> Actix-web</a></li></ol></li><li class="chapter-item expanded "><a href="advanced_topics.html"><strong aria-hidden="true">8.</strong> Advanced topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom_scalars.html"><strong aria-hidden="true">8.1.</strong> Custom scalars</a></li><li class="chapter-item expanded "><a href="dataloader.html"><strong aria-hidden="true">8.2.</strong> Optimizing N+1 queries</a></li><li class="chapter-item expanded "><a href="custom_directive.html"><strong aria-hidden="true">8.3.</strong> Custom directive</a></li><li class="chapter-item expanded "><a href="apollo_federation.html" class="active"><strong aria-hidden="true">8.4.</strong> Apollo Federation</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Async-graphql Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="apollo-federation"><a class="header" href="#apollo-federation">Apollo Federation</a></h1>
<p>Apollo Federation is a GraphQL architecture for combining multiple GraphQL services, or subgraphs, into a single supergraph. You can read more in the <a href="https://www.apollographql.com/docs/apollo-server/federation/">official documentation</a>.</p>
<blockquote>
<p>To see a complete example of federation, check out the <a href="https://github.com/async-graphql/examples/tree/master/federation">federation example</a>. </p>
</blockquote>
<h2 id="enabling-federation-support"><a class="header" href="#enabling-federation-support">Enabling federation support</a></h2>
<p><code>async-graphql</code> supports all the functionality of Apollo Federation v2. Support will be enabled automatically if any <code>#[graphql(entity)]</code> resolvers are found in the schema. To enable it manually, use the <code>enable_federation</code> method on the <code>SchemaBuilder</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">struct Query;
</span><span class="boring">#[Object]
</span><span class="boring">impl Query {
</span><span class="boring">   async fn hello(&amp;self) -&gt; String { &quot;Hello&quot;.to_string() }
</span><span class="boring">}
</span>fn main() {
  let schema = Schema::build(Query, EmptyMutation, EmptySubscription)
    .enable_federation()
    .finish();
  // ... Start your server of choice
}</code></pre></pre>
<p>This will define the <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#link"><code>@link</code> directive</a> on your schema to enable Federation v2.</p>
<h2 id="entities-and-key"><a class="header" href="#entities-and-key">Entities and <code>@key</code></a></h2>
<p><a href="https://www.apollographql.com/docs/federation/entities">Entities</a> are a core feature of federation, they allow multiple subgraphs to contribute fields to the same type. An entity is a GraphQL <code>type</code> with at least one <a href="https://www.apollographql.com/docs/federation/entities#1-define-a-key"><code>@key</code> directive</a>. To create a <a href="https://www.apollographql.com/docs/federation/entities#1-define-a-key"><code>@key</code></a> for a type, create a reference resolver using the <code>#[graphql(entity)]</code> attribute. This resolver should be defined on the <code>Query</code> struct, but will not appear as a field in the schema.</p>
<blockquote>
<p>Even though a reference resolver looks up an individual entity, it is <strong>crucial that you use a <a href="dataloader.html">dataloader</a></strong> in the implementation. The federation router will look up entities in batches, which can quickly lead the N+1 performance issues.</p>
</blockquote>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct User { id: ID }
</span>struct Query;

#[Object]
impl Query {
    #[graphql(entity)]
    async fn find_user_by_id(&amp;self, id: ID) -&gt; User {
        User { id }
    }

    #[graphql(entity)]
    async fn find_user_by_id_with_username(&amp;self, #[graphql(key)] id: ID, username: String) -&gt; User {
        User { id }
    }

    #[graphql(entity)]
    async fn find_user_by_id_and_username(&amp;self, id: ID, username: String) -&gt; User {
        User { id }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Notice the difference between these three lookup functions, which are all looking for the <code>User</code> object.</strong></p>
<ul>
<li>
<p><code>find_user_by_id</code>: Use <code>id</code> to find a <code>User</code> object, the key for <code>User</code> is <code>id</code>.</p>
</li>
<li>
<p><code>find_user_by_id_with_username</code>: Use <code>id</code> to find an <code>User</code> object, the key for <code>User</code> is <code>id</code>, and the <code>username</code> field value of the <code>User</code> object is requested (e.g., via <code>@external</code> and <code>@requires</code>).</p>
</li>
<li>
<p><code>find_user_by_id_and_username</code>: Use <code>id</code> and <code>username</code> to find an <code>User</code> object, the keys for <code>User</code> are <code>id</code> and <code>username</code>.</p>
</li>
</ul>
<p>The resulting schema will look like this:</p>
<pre><code class="language-graphql">type Query {
  # These fields will not be exposed to users, they are only used by the router to resolve entities
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!
}

type User @key(fields: &quot;id&quot;) @key(fields: &quot;id username&quot;) {
  id: ID!
}
</code></pre>
<h3 id="defining-a-compound-primary-key"><a class="header" href="#defining-a-compound-primary-key">Defining a compound primary key</a></h3>
<p>A single primary key can consist of multiple fields, and even nested fields, you can use <code>InputObject</code> to implements a nested primary key.</p>
<p>In the following example, the primary key of the <code>User</code> object is <code>key { a b }</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct User { key: Key }
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct Key { a: i32, b: i32 }
</span>#[derive(InputObject)]
struct NestedKey {
  a: i32,
  b: i32,
}

struct Query;

#[Object]
impl Query {
  #[graphql(entity)]
  async fn find_user_by_key(&amp;self, key: NestedKey) -&gt; User {
    let NestedKey { a, b } = key;
    User { key: Key{a, b} }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>The resulting schema will look like this:</p>
<pre><code class="language-graphql">type Query {
  # These fields will not be exposed to users, they are only used by the router to resolve entities
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!
}

type User @key(fields: &quot;key { a b }&quot;) {
  key: Key!
}

type Key {
  a: Int!
  b: Int!
}
</code></pre>
<h3 id="creating-unresolvable-entities"><a class="header" href="#creating-unresolvable-entities">Creating unresolvable entities</a></h3>
<p>There are certain times when you need to reference an entity, but not add any fields to it. This is particularly useful when you want to link data from separate subgraphs together, but neither subgraph has all the data.</p>
<p>If you wanted to implement the <a href="https://www.apollographql.com/docs/federation/entities/#referencing-an-entity-without-contributing-fields">products and reviews subgraphs example</a> from the Apollo Docs, you would create the following types for the reviews subgraph:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
struct Review {
    product: Product,
    score: u64,
}

#[derive(SimpleObject)]
#[graphql(unresolvable)]
struct Product {
    id: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>This will add the <code>@key(fields: &quot;id&quot;, resolvable: false)</code> directive to the <code>Product</code> type in the reviews subgraph.</p>
<p>For more complex entity keys, such as ones with nested fields in compound keys, you can override the fields in the directive as so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(unresolvable = &quot;id organization { id }&quot;)]
struct User {
    id: u64,
    organization: Organization,
}

#[derive(SimpleObject)]
struct Organization {
    id: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>However, it is important to note that no validation will be done to check that these fields exist.</p>
<h2 id="shareable"><a class="header" href="#shareable"><code>@shareable</code></a></h2>
<p>Apply the <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#shareable"><code>@shareable</code> directive</a> to a type or field to indicate that multiple subgraphs can resolve it.</p>
<h3 id="shareable-fields"><a class="header" href="#shareable-fields"><code>@shareable</code> fields</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(complex)]
struct Position {
  #[graphql(shareable)]
  x: u64,
}

#[ComplexObject]
impl Position {
  #[graphql(shareable)]
  async fn y(&amp;self) -&gt; u64 {
    0
  }
}
<span class="boring">}</span></code></pre></pre>
<p>The resulting schema will look like this:</p>
<pre><code class="language-graphql">type Position {
  x: Int! @shareable
  y: Int! @shareable
}
</code></pre>
<h3 id="shareable-type"><a class="header" href="#shareable-type"><code>@shareable</code> type</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(shareable)]
struct Position {
  x: u64,
  y: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>The resulting schema will look like this:</p>
<pre><code class="language-graphql">type Position @shareable {
  x: Int!
  y: Int!
}
</code></pre>
<h2 id="inaccessible"><a class="header" href="#inaccessible"><code>@inaccessible</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#inaccessible"><code>@inaccessible</code> directive</a> is used to omit something from the supergraph schema (e.g., if it's not yet added to all subgraphs which share a <code>@shareable</code> type).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(shareable)]
struct Position {
  x: u32,
  y: u32,
  #[graphql(inaccessible)]
  z: u32,
} 
<span class="boring">}</span></code></pre></pre>
<p>Results in:</p>
<pre><code class="language-graphql">type Position @shareable {
  x: Int!
  y: Int!
  z: Int! @inaccessible
}
</code></pre>
<h2 id="override"><a class="header" href="#override"><code>@override</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#override"><code>@override</code> directive</a> is used to take ownership of a field from another subgraph. This is useful for migrating a field from one subgraph to another.</p>
<p>For example, if you add a new &quot;Inventory&quot; subgraph which should take over responsibility for the <code>inStock</code> field currently provided by the &quot;Products&quot; subgraph, you might have something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
struct Product {
  id: ID,
  #[graphql(override_from = &quot;Products&quot;)]
  in_stock: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>Which results in:</p>
<pre><code class="language-graphql">type Product @key(fields: &quot;id&quot;) {
  id: ID!
  inStock: Boolean! @override(from: &quot;Products&quot;)
}
</code></pre>
<h2 id="external"><a class="header" href="#external"><code>@external</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#external"><code>@external</code> directive</a> is used to indicate that a field is usually provided by another subgraph, but is sometimes required by this subgraph (when combined with <code>@requires</code>) or provided by this subgraph (when combined with <code>@provides</code>).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
struct Product {
  id: ID,
  #[graphql(external)]
  name: String,
  in_stock: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>Results in:</p>
<pre><code class="language-graphql">type Product {
  id: ID!
  name: String! @external
  inStock: Boolean!
}
</code></pre>
<h2 id="provides"><a class="header" href="#provides"><code>@provides</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#provides"><code>@provides</code> directive</a> is used to indicate that a field is provided by this subgraph, but only sometimes.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
struct Product {
    id: ID,
    #[graphql(external)]
    human_name: String,
    in_stock: bool,
}

struct Query;

#[Object]
impl Query {
    /// This operation will provide the `humanName` field on `Product
    #[graphql(provides = &quot;humanName&quot;)]
    async fn out_of_stock_products(&amp;self) -&gt; Vec&lt;Product&gt; {
      vec![Product {
        id: &quot;1&quot;.into(),
        human_name: &quot;My Product&quot;.to_string(),
        in_stock: false,
      }]
    }
    async fn discontinued_products(&amp;self) -&gt; Vec&lt;Product&gt; {
        vec![Product {
            id: &quot;2&quot;.into(),
            human_name: String::new(),  // This is ignored by the router
            in_stock: false,
        }]
    }
    #[graphql(entity)]
    async fn find_product_by_id(&amp;self, id: ID) -&gt; Product {
        Product {
            id,
            human_name: String::new(),  // This is ignored by the router
            in_stock: true,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that the <code>#[graphql(provides)]</code> attribute takes the field name as it appears in the schema, not the Rust field name.</p>
<p>The resulting schema will look like this:</p>
<pre><code class="language-graphql">type Product @key(fields: &quot;id&quot;) {
    id: ID!
    humanName: String! @external
    inStock: Boolean!
}

type Query {
    outOfStockProducts: [Product!]! @provides(fields: &quot;humanName&quot;)
    discontinuedProducts: [Product!]!
}
</code></pre>
<h2 id="requires"><a class="header" href="#requires"><code>@requires</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#requires"><code>@requires</code> directive</a> is used to indicate that an <code>@external</code> field is required for this subgraph to resolve some other field(s). If our <code>shippingEstimate</code> field requires the <code>size</code> and <code>weightInPounts</code> fields, then we might want a subgraph entity which looks like this:</p>
<pre><code class="language-graphql">type Product @key(fields: &quot;id&quot;) {
  id: ID!
  size: Int! @external
  weightInPounds: Int! @external
  shippingEstimate: String! @requires(fields: &quot;size weightInPounds&quot;)
}
</code></pre>
<p>In order to implement this in Rust, we can use the <code>#[graphql(requires)]</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(complex)]
struct Product {
  id: ID,
  #[graphql(external)]
  size: u32,
  #[graphql(external)]
  weight_in_pounds: u32,
}

#[ComplexObject]
impl Product {
  #[graphql(requires = &quot;size weightInPounds&quot;)]
  async fn shipping_estimate(&amp;self) -&gt; String {
    let price = self.size * self.weight_in_pounds;
    format!(&quot;${}&quot;, price)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that we use the GraphQL field name <code>weightInPounds</code>, not the Rust field name <code>weight_in_pounds</code> in <code>requires</code>. To populate those external fields, we add them as arguments in the entity resolver:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct Product {
</span><span class="boring">    id: ID,
</span><span class="boring">    #[graphql(external)]
</span><span class="boring">    size: u32,
</span><span class="boring">    #[graphql(external)]
</span><span class="boring">    weight_in_pounds: u32,
</span><span class="boring">}
</span><span class="boring">struct Query;
</span>#[Object]
impl Query {
  #[graphql(entity)]
  async fn find_product_by_id(
    &amp;self, 
    #[graphql(key)] id: ID, 
    size: Option&lt;u32&gt;, 
    weight_in_pounds: Option&lt;u32&gt;
  ) -&gt; Product {
    Product {
      id,
      size: size.unwrap_or_default(),
      weight_in_pounds: weight_in_pounds.unwrap_or_default(),
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>The inputs are <code>Option&lt;&gt;</code> even though the fields are required. This is because the external fields are <em>only</em> passed to the subgraph when the field(s) that require them are being selected. If the <code>shippingEstimate</code> field is not selected, then the <code>size</code> and <code>weightInPounds</code> fields will not be passed to the subgraph. <strong>Always use optional types for external fields.</strong></p>
<p>We have to put <em>something</em> in place for <code>size</code> and <code>weight_in_pounds</code> as they are still required fields on the type, so we use <code>unwrap_or_default()</code> to provide a default value. This looks a little funny, as we're populating the fields with nonsense values, but we have confidence that they will not be needed if they were not provided.  <strong>Make sure to use <code>@requires</code> if you are consuming <code>@external</code> fields, or your code will be wrong.</strong></p>
<h3 id="nested-requires"><a class="header" href="#nested-requires">Nested <code>@requires</code></a></h3>
<p>A case where the <code>@requires</code> directive can be confusing is when there are nested entities. For example, if we had an <code>Order</code> type which contained a <code>Product</code>, then we would need an entity resolver like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">pub struct Order { id: ID }
</span><span class="boring">struct Query;
</span>#[Object]
impl Query {
  #[graphql(entity)]
  async fn find_order_by_id(&amp;self, id: ID) -&gt; Option&lt;Order&gt; {
      Some(Order { id })
  }
}
<span class="boring">}</span></code></pre></pre>
<p>There are no inputs on this entity resolver, so how do we populate the <code>size</code> and <code>weight_in_pounds</code> fields on <code>Product</code> if a user has a query like <code>order { product { shippingEstimate } }</code>? The supergraph implementation will solve this for us by calling the <code>find_product_by_id</code> separately for any fields which have a <code>@requires</code> directive, so the subgraph code does not need to worry about how entities relate.</p>
<h2 id="tag"><a class="header" href="#tag"><code>@tag</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#tag"><code>@tag</code> directive</a> is used to add metadata to a schema location for features like <a href="https://www.apollographql.com/docs/studio/contracts/">contracts</a>. To add a tag like this:</p>
<pre><code class="language-graphql">type User @tag(name: &quot;team-accounts&quot;) {
  id: String!
  name: String!
}
</code></pre>
<p>You can write code like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(tag = &quot;team-accounts&quot;)]
struct User {
  id: ID,
  name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="composedirective"><a class="header" href="#composedirective"><code>@composeDirective</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federation-spec/#composedirective"><code>@composeDirective</code> directive</a> is used to add a custom type system directive to the supergraph schema. Without <code>@composeDirective</code>, and <a href="./custom_directive#type-system-directives">custom type system directives</a> are omitted from the composed supergraph schema. To include a custom type system directive as a composed directive, just add the <code>composable</code> attribute to the <code>#[TypeDirective]</code> macro:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[TypeDirective(
    location = &quot;Object&quot;,
    composable = &quot;https://custom.spec.dev/extension/v1.0&quot;,
)]
fn custom() {}
<span class="boring">}</span></code></pre></pre>
<p>In addition to the <a href="./custom_directive#type-system-directives">normal type system directive behavior</a>, this will add the following bits to the output schema:</p>
<pre><code class="language-graphql">extend schema @link(
	url: &quot;https://custom.spec.dev/extension/v1.0&quot;
	import: [&quot;@custom&quot;]
)
	@composeDirective(name: &quot;@custom&quot;)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="custom_directive.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="custom_directive.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
