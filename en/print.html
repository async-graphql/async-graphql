<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Async-graphql Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Async-graphql Book">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="typesystem.html"><strong aria-hidden="true">3.</strong> Type System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="define_simple_object.html"><strong aria-hidden="true">3.1.</strong> SimpleObject</a></li><li class="chapter-item expanded "><a href="define_complex_object.html"><strong aria-hidden="true">3.2.</strong> Object</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="context.html"><strong aria-hidden="true">3.2.1.</strong> Context</a></li><li class="chapter-item expanded "><a href="error_handling.html"><strong aria-hidden="true">3.2.2.</strong> Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="define_enum.html"><strong aria-hidden="true">3.3.</strong> Enum</a></li><li class="chapter-item expanded "><a href="define_interface.html"><strong aria-hidden="true">3.4.</strong> Interface</a></li><li class="chapter-item expanded "><a href="define_union.html"><strong aria-hidden="true">3.5.</strong> Union</a></li><li class="chapter-item expanded "><a href="define_input_object.html"><strong aria-hidden="true">3.6.</strong> InputObject</a></li></ol></li><li class="chapter-item expanded "><a href="define_schema.html"><strong aria-hidden="true">4.</strong> Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="query_and_mutation.html"><strong aria-hidden="true">4.1.</strong> Query and Mutation</a></li><li class="chapter-item expanded "><a href="subscription.html"><strong aria-hidden="true">4.2.</strong> Subscription</a></li></ol></li><li class="chapter-item expanded "><a href="utilities.html"><strong aria-hidden="true">5.</strong> Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input_value_validators.html"><strong aria-hidden="true">5.1.</strong> Input value validators</a></li><li class="chapter-item expanded "><a href="cache_control.html"><strong aria-hidden="true">5.2.</strong> Cache control</a></li><li class="chapter-item expanded "><a href="cursor_connections.html"><strong aria-hidden="true">5.3.</strong> Cursor connections</a></li><li class="chapter-item expanded "><a href="error_extensions.html"><strong aria-hidden="true">5.4.</strong> Error extensions</a></li><li class="chapter-item expanded "><a href="apollo_tracing.html"><strong aria-hidden="true">5.5.</strong> Apollo Tracing</a></li></ol></li><li class="chapter-item expanded "><a href="integrations.html"><strong aria-hidden="true">6.</strong> Integrations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrations_to_warp.html"><strong aria-hidden="true">6.1.</strong> Warp</a></li><li class="chapter-item expanded "><a href="integrations_to_actix_web.html"><strong aria-hidden="true">6.2.</strong> Actix-web</a></li></ol></li><li class="chapter-item expanded "><a href="advanced_topics.html"><strong aria-hidden="true">7.</strong> Advanced topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom_scalars.html"><strong aria-hidden="true">7.1.</strong> Custom scalars</a></li><li class="chapter-item expanded "><a href="custom_extensions.html"><strong aria-hidden="true">7.2.</strong> Custom extensions</a></li><li class="chapter-item expanded "><a href="custom_subscription_transport.html"><strong aria-hidden="true">7.3.</strong> Custom subscription transport</a></li><li class="chapter-item expanded "><a href="apollo_federation.html"><strong aria-hidden="true">7.4.</strong> Apollo Federation</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Async-graphql Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p><code>Async-graphql</code> is a GraphQL server-side library implemented in Rust. It is fully compatible with the GraphQL specification and most of its extensions, and offers type safety and high performance.</p>
<p>You can define a Schema in Rust and procedural macros will automatically generate code for a GraphQL query. This library does not extend Rust's syntax, which means that Rustfmt can be used normally. I value this highly and it is one of the reasons why I developed <code>Async-graphql</code>.</p>
<h2><a class="header" href="#why-do-this" id="why-do-this">Why do this?</a></h2>
<p>I like GraphQL and Rust. I've been using <code>Juniper</code>, which solves the problem of implementing a GraphQL server with Rust. But Juniper had several problems, the most important of which is that it didn't support async/await at the time. So I decided to make this library for myself.</p>
<h2><a class="header" href="#progress" id="progress">Progress</a></h2>
<p>As I write this document today (April 15, 2020), a month and a half after I started <code>Async-graphql</code> development, it has surpassed my goal of becoming a fully functional graphql server library.</p>
<h1><a class="header" href="#quickstart" id="quickstart">Quickstart</a></h1>
<h2><a class="header" href="#add-dependency-libraries" id="add-dependency-libraries">Add dependency libraries</a></h2>
<pre><code class="language-toml">[dependencies]
async-graphql = &quot;1.11.0&quot;
async-graphql-actix-web = &quot;1.3.0&quot; # If you need to integrate into actix-web
async-graphql-warp = &quot;1.3.0&quot; If you need to integrate into warp
async-graphql-tide = &quot;1.2.0&quot; # If you need to integrate into tide
</code></pre>
<h2><a class="header" href="#write-a-schema" id="write-a-schema">Write a Schema</a></h2>
<p>The Schema of a GraphQL contains a required Query, an optional Mutation, and an optional Subscription. These object types are described using the structure of the Rust language. The field of the structure corresponds to the field of the GraphQL object, but you need to mark it with <code>#[field]</code> so that the procedure macro provided by <code>Async-graphql</code> can correctly recognize it.</p>
<p><code>Async-graphql</code> implements the mapping of common data types to GraphQL types, such as <code>i32</code>, <code>f64</code>, <code>Option&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, etc. Also, you can <a href="custom_scalars.html">extend these base types</a>, which are called scalars in the GraphQL.</p>
<p>Here is a simple example where we provide just one query that returns the sum of <code>a</code> and <code>b</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    #[field(desc = &quot;Returns the sum of a and b&quot;)]
    async fn add(a: i32, b: i32) -&gt; i32 {
        a + b
    }
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#execute-the-query" id="execute-the-query">Execute the query</a></h2>
<p>In our example, there is only Query without Mutation and Subscription, so we create the Schema with <code>EmptyMutation</code> and <code>EmptySubscription</code>, and then call <code>Schema::execute</code> to execute the Query.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let schema = Schema::new(MySchema, EmptyMutation, EmptySubscription);
let res = schema.execute(&quot;{ add(a: 10, b: 20) }&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#output-the-query-results-as-json" id="output-the-query-results-as-json">Output the query results as JSON</a></h2>
<p>Query returns <code>async_graphql::Result</code> with <code>async_graphql::http::GQLResponse </code> wrapped, can be directly converted to JSON.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let json = serde_json::to_vec(async_graphql::http::GQLResponse(res));
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#web-server-integration" id="web-server-integration">Web server integration</a></h2>
<p>Please refer to https://github.com/async-graphql/examples.</p>
<h1><a class="header" href="#type-system" id="type-system">Type System</a></h1>
<p><code>Async-graphql</code> implemented conversion from GraphQL Object to Rust struct, and it's easy to use.</p>
<h1><a class="header" href="#simpleobject" id="simpleobject">SimpleObject</a></h1>
<p><code>SimpleObject</code> directly map all field of a struct to GraphQL object, you cannot define a Resolve function on it.</p>
<p>The example below defined an object <code>MyObject</code>, including field <code>a</code> and <code>b</code>. <code>c</code> will be not mapped to GraphQL as it is labelled as <code>#[field(skip)]</code></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

#[SimpleObject]
struct MyObject {
    a: i32,
    b: i32,

    #[field(skip)]
    c: i32,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#object" id="object">Object</a></h1>
<p>Different from <code>SimpleObject</code>, <code>Object</code> must have Resolve defined for each field in <code>impl</code>.</p>
<p><strong>A Resolve function has to be asynchronous. The first argument has to be <code>&amp;self</code>, second being optional <code>Context</code> and followed by field arguments.</strong></p>
<p>Resolve is used to get the value of the field. You can query a database and return the result. <strong>The return type of the function is the type of the field.</strong> You can also return a <code>async_graphql::FieldResult</code> so to return an error if it occrs and error message will be send to query result.</p>
<p>When querying a database, you may need a global data base connection pool.
When creating <code>Schema</code>,  you can use <code>SchemaBuilder::data</code> to setup <code>Schema</code> data, and <code>Context::data</code> to setup <code>Context</code>data.
The following <code>value_from_db</code> function showed how to retrive a database connection from <code>Context</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct MyObject {
    value: i32,
}

#[Object]
impl MyObject {
    async fn value(&amp;self) -&gt; String {
        self.value.to_string()
    }

    async fn value_from_db(
        &amp;self,
        ctx: &amp;Context&lt;'_'&gt;,
        #[arg(desc = &quot;Id of object&quot;)] id: i64
    ) -&gt; FieldResult&lt;String&gt; {
        let conn = ctx.data::&lt;DbPool&gt;().take();
        Ok(conn.query_something(id)?.name)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#context" id="context">Context</a></h1>
<p>The main goal of <code>Context</code> is to acquire global data attached to Schema. <strong>Note that if the return value of resolve function is borrowed from <code>Context</code>, you need to explictly state the lifetime of the argument.</strong></p>
<p>The following example shows how to borrow data in <code>Context</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    async fn borrow_from_context_data&lt;'ctx'&gt;(
        &amp;self,
        ctx: &amp;'ctx Context&lt;'_&gt;
    ) -&gt; &amp;'ctx String {
        ctx.data::&lt;String&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#error-handling" id="error-handling">Error handling</a></h1>
<p>Resolve can return a <code>FieldResult</code>, following is the definition:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type FieldResult&lt;T&gt; = std::result::Result&lt;T, FieldError&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Any <code>Error</code> can be converted to <code>FieldError</code> and you can extend error message.</p>
<p>Following example shows how to parse an input string to integer. When parsing failed, it would return error and attach error message.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    #[field]
    async fn parse_with_extensions(&amp;self, input: String) -&gt; FieldResult&lt;i32&gt; {
        Ok(&quot;234a&quot;
            .parse()
            .map_err(|err| err.extend_with(|_| json!({&quot;code&quot;: 400})))?)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#enum" id="enum">Enum</a></h1>
<p>It's easy to define an <code>Enum</code>, here we have an example:</p>
<p><strong>Async-graphql can automatically change the name of each item to GraphQL's CONSTANT_CASE convension, you can also use <code>name</code> to rename.</strong></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

#[Enum(desc = &quot;One of the films in the Star Wars Trilogy&quot;)]
pub enum Episode {
    #[item(desc = &quot;Released in 1977.&quot;)]
    NewHope,

    #[item(desc = &quot;Released in 1980.&quot;)]
    Empire,

    // rename to `AAA`
    #[item(name=&quot;AAA&quot;, desc = &quot;Released in 1983.&quot;)]
    Jedi,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#interface" id="interface">Interface</a></h1>
<p><code>Interface</code> is used to abstract <code>Object</code>s with common fields.
<code>Async-graphql</code> implemented it as a wrapper.
The wrapper will forward Resolve to the <code>Object</code> that implemented this <code>Interface</code>.
Therefore, the <code>Object</code>'s fields' type, arguments must match with the <code>Interface</code>'s.</p>
<p><code>Async-graphql</code> implemented auto conversion from <code>Object</code> to <code>Interface</code>, you only need to call <code>Into::into</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Circle {
    radius: f32,
}

#[Object]
impl Circle {
    async fn area(&amp;self) -&gt; f32 {
        std::f32::consts::PI * self.radius * self.radius
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Circle { radius: self.radius * s }.into()
    }
}

struct Square {
    width: f32,
}

#[Object]
impl Square {
    async fn area(&amp;self) -&gt; f32 {
        self.width * self.width
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Square { width: self.width * s }.into()
    }
}

#[Interface(
    field(name = &quot;area&quot;, type = &quot;f32&quot;),
    field(name = &quot;scale&quot;, type = &quot;Shape&quot;, arg(name = &quot;s&quot;, type = &quot;f32&quot;))
)]
enum Shape {
    Circle(Circle),
    Square(Square),
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#union" id="union">Union</a></h1>
<p>The definition of <code>Union</code> is similar to <code>Interface</code>'s, <strong>but no field allowed.</strong>.
The implemention is quite similar for <code>Async-graphql</code>.
From <code>Async-graphql</code>'s perspective, <code>Union</code> is a subset of <code>Interface</code>.</p>
<p>The following example modified the definition of <code>Interface</code> a little bit and removed fields.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Circle {
    radius: f32,
}

#[Object]
impl Circle {
    async fn area(&amp;self) -&gt; f32 {
        std::f32::consts::PI * self.radius * self.radius
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Circle { radius: self.radius * s }.into()
    }
}

struct Square {
    width: f32,
}

#[Object]
impl Square {
    async fn area(&amp;self) -&gt; f32 {
        self.width * self.width
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Square { width: self.width * s }.into()
    }
}

#[Union]
enum Shape {
    Circle(Circle),
    Square(Square),
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#inputobject" id="inputobject">InputObject</a></h1>
<!--Input Object and SimpleObject inconsistant space.-->
<p>You can define an <code>Object</code> as argument, GraphQL calls it <code>InputObject</code>.
The definition of <code>InputObject</code> is similar to <a href="define_simple_object.html">SimpleObject</a>.
However, <code>SimpleObject</code> can only be used for output and <code>InputObject</code> can only be used as input.</p>
<p><code>InputObject</code> don't need a <code>#[field]</code> for each field, every field is <code>InputValue</code>.
But you can add optional <code>#[field]</code> to add description or rename the field.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

#[InputObject]
struct Coordinate {
    latitude: f64,

    #[field(desc = &quot;...&quot;)]
    longitude: f64
}

struct Mutation;

#[Object]
impl Mutation {
    async fn users_at_location(&amp;self, coordinate: Coordinate, radius: f64) -&gt; Vec&lt;User&gt; {
        // Writes coordination to database.
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#schema" id="schema">Schema</a></h1>
<p>After defining the basic types, you need to define a schema to combine them. The schema consists of three types: a query object, mutation object, and subscription object, where the mutation object and subscription object are optional.</p>
<p>When the schema is created, <code>Async-Graphql</code> will traverse all object graphs and register all types. This means that if a GraphQL object is defined but never referenced, then this object will not be exposed in the schema.</p>
<h1><a class="header" href="#query-and-mutation" id="query-and-mutation">Query and Mutation</a></h1>
<h2><a class="header" href="#query-root-object" id="query-root-object">Query root object</a></h2>
<p>The query root object is a GraphQL object with a definition similar to other objects. Resolve functions for all fields of the query object are executed concurrently.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    async fn user(&amp;self, username: String) -&gt; FieldResult&lt;Option&lt;User&gt;&gt; {
        // Look up users from the database
    }
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#mutation-root-object" id="mutation-root-object">Mutation root object</a></h2>
<p>The mutation root object is also a GraphQL object, but it executes sequentially. One mutation following from another will only be executed only after the first mutation is completed.</p>
<p>The following mutation root object provides an example of user registration and login:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Mutation;

#[Object]
impl Mutation {
    async fn signup(&amp;self, username: String, password: String) -&gt; Result&lt;bool&gt; {
        // User signup
    }

    async fn login(&amp;self, username: String, password: String) -&gt; Result&lt;String&gt; {
        // User login (generate token)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#subscription" id="subscription">Subscription</a></h1>
<p>The definition of the subscription root object is slightly different from other root objects. Its Resolve function always returns a Stream, and the field parameters are usually used as data filtering conditions.</p>
<p>The following example subscribes to an integer stream, which generates one integer per second. The parameter step specifies the integer step size with a default of 1</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Subscription;

#[Subscription]
impl Subscription {
    async fn integers(&amp;self, #[arg(default = &quot;1&quot;)] step: i32) -&gt; impl Stream&lt;Item = i32&gt; {
        let mut value = 0;
        tokio::time::interval(Duration::from_secs(1)).map(move |_| {
            value += step;
            value
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#utilities" id="utilities">Utilities</a></h1>
<h1><a class="header" href="#input-value-validators" id="input-value-validators">Input value validators</a></h1>
<p>Arguments to a query (<a href="define_input_object.html">InputObject</a>) are called <code>Input Objects</code> in GraphQL. If the provided input type does not match for a query, the query will return a type mismatch error. But sometimes we want to provide more restrictions on specific types of values. For example, we might want to require that an argument is a valid email address. Async-graphql provides an input validators to solve this problem.</p>
<p>An input validator can be combined via <code>and</code> and <code>or</code> operators.</p>
<p>The following is an input validator which checks that a <code>String</code> is a valid Email or MAC address:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
use async_graphql::validators::{Email, MAC};

struct Query;

#[Object]
impl Query {
    async fn input(#[arg(validator(or(Email, MAC(colon = &quot;false&quot;))))] a: String) {
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The following example verifies that the <code>i32</code> parameter <code>a</code> is greater than 10 and less than 100, or else equal to 0:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql:*;
use async_graphql::validators::{IntGreaterThan, IntLessThan, IntEqual};

struct Query;

#[Object]
impl Query {
    async fn input(#[validator(
        or(
            and(IntGreaterThan(value = &quot;10&quot;), IntLessThan(value = &quot;100&quot;)),
            IntEqual(value = &quot;0&quot;)
        ))] a: String) {
    } {
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#custom-validator" id="custom-validator">Custom validator</a></h2>
<p>Here is an example of a custom validator:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct MustBeZero {}

impl InputValueValidator for InputValueValidator {
    fn is_valid(&amp;self, value: &amp;Value) -&gt; Option&lt;String&gt; {
        if let Value::Int(n) = value {
            if n.as_i64().unwrap() != 0 {
                // Validation failed
                Some(format!(
                    &quot;the value is {}, but must be zero&quot;,
                    n.as_i64().unwrap(),
                ))
            } else {
                // Validation succeeded
                None
            }
        } else {
            // If the type does not match we can return None and built-in validations
            // will pick up on the error
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#cache-control" id="cache-control">Cache control</a></h1>
<p>Production environments often rely on caching to improve performance.</p>
<p>A GraphQL query will call multiple resolver functions and each resolver can have a different cache definition. Some may cache for a few seconds, some may cache for a few hours, some may be the same for all users, and some may be different for each session.</p>
<p><code>Async-Graphql</code> provides a mechanism that allows you to define the cache time and scope for each resolver.</p>
<p>You can define cache parameters on the object or on its fields. The following example shows two uses of cache control parameters.</p>
<p>You can use <code>max_age</code> parameters to control the age of the cache (in seconds), and you can also use <code>public</code> and <code>private</code> to control the scope of the cache. When you do not specify it, the scope will default to <code>public</code>.</p>
<p>lWhen querying multiple resolvers, the results of all cache control parameters will be combined and the <code>max_age</code> minimum value will be taken. If the scope of any object or field is <code>private</code>, the result will be <code>private</code>.</p>
<p>We can use <code>QueryResponse</code> to get a merged cache control result from a query result, and call <code>CacheControl::value</code> to get the corresponding HTTP header.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[Object(cache_control(max_age = 60))]
impl Query {
    #[field(cache_control(max_age = 30))]
    async fn value1(&amp;self) -&gt; i32 {
    }

    #[field(cache_control(private))]
    async fn value2(&amp;self) -&gt; i32 {
    }

    async fn value3(&amp;self) -&gt; i32 {
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The following are different queries corresponding to different cache control results:</p>
<pre><code class="language-graphql"># max_age=30
{ value1 }
</code></pre>
<pre><code class="language-graphql"># max_age=30, private
{ value1 value2 }
</code></pre>
<pre><code class="language-graphql"># max_age=60
{ value3 }
</code></pre>
<h1><a class="header" href="#cursor-connections" id="cursor-connections">Cursor connections</a></h1>
<p>Relay's cursor connection specification is defined to provide a consistent method for query paging. For more details on the specification see the <a href="https://facebook.github.io/relay/graphql/connections.htm">GraphQL Cursor Connections Specification</a>。</p>
<p>It is simple to define a cursor connection in <code>Async-GraphQL</code></p>
<ol>
<li>Implement <code>async_graphql::DataSource</code> and write the <code>query_operation</code> function.</li>
<li>Call <code>DataSource::query</code> in the field's resolve function and return the result.</li>
</ol>
<p>Here is a simple data source that returns continuous integers:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Integers;

#[DataSource]
impl DataSource for Integers {
    // Type for response
    type Element = i32;

    // We don't need to extend the edge fields, so this can be empty
    type EdgeFieldsObj = EmptyEdgeFields;

    async fn query_operation(&amp;self, _ctx: &amp;Context&lt;'_&gt;, operation: &amp;QueryOperation&lt;'_&gt;) -&gt; FieldResult&lt;Connection&lt;Self::Element, Self::EdgeFieldsObj&gt;&gt; {
        let (start, end) = match operation {
            // Look from beginning up to limit
            QueryOperation::First {limit} =&gt; {
                let start = 0;
                let end = start + *limit as i32;
                (start, end)
            }
            QueryOperation::FirstAfter {after, limit} =&gt; {
                // Look after number up to limit
                let start = after.parse::&lt;i32&gt;()
                    .ok()
                    .map(|after| after + 1)
                    .unwrap_or(0);
                (start, end + start + *limit)
            }
            // Look backward from last element up to limit
            QueryOperation::Last {limit} =&gt; {
                let end = 0;
                let start = end - *limit as i32;
                (start, end)
            }
            QueryOperation::LastBefore {before, limit} =&gt; {
                // Look before number up to limit
                let end = before.parse::&lt;i32&gt;()
                    .ok()
                    .unwrap_or(0);
                (end - *limit, end)
            }
            // TODO: Need to handle all conditions
            _ =&gt; (0, 10)
        };

        // Create nodes. Each node is a tuple containing three values: the cursor, extended edge object, and node value
        let nodes = (start..end).into_iter().map(|n| (n.to_string(), EmptyEdgeFields, n)).collect();

        Ok(Connection::new(None, true, true, nodes))
    }
}

struct Query;

#[Object]
impl Query {
    #[field]
    async fn numbers(&amp;self,
        ctx: &amp;Context&lt;'_&gt;,
        after: Option&lt;String&gt;,
        before: Option&lt;String&gt;,
        first: Option&lt;i32&gt;,
        last: Option&lt;i32&gt;,
    ) -&gt; FieldResult&lt;Connection&lt;i32, EmptyEdgeFields&gt;&gt; {
        // Make the query
        Integers.query(ctx, after, before, first, last).await
    }
}

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#error-extensions" id="error-extensions">Error extensions</a></h1>
<h1><a class="header" href="#apollo-tracing" id="apollo-tracing">Apollo Tracing</a></h1>
<p>Apollo Tracing provides performance analysis results for each step of query. This is an extension to <code>Schema</code>, and the performance analysis results are stored in <code>QueryResponse</code>.</p>
<p>To enable the Apollo Tracing extension, add the extension when a <code>Schema</code> is created.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
use async_graphql::extensions::ApolloTracing;

let schema = Schema::build(Query, EmptyMutation, EmptySubscription)
    .extension(|| ApolloTracing::default()) // Enable ApolloTracing extension
    .finish();

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#integrations" id="integrations">Integrations</a></h1>
<p><code>Async-Graphql</code> supports several common Rust web servers.</p>
<ul>
<li>Actix-web <a href="https://crates.io/crates/async-graphql-actix-web">async-graphql-actix-web</a></li>
<li>Warp <a href="https://crates.io/crates/async-graphql-warp">async-graphql-warp</a></li>
</ul>
<p><strong>Even if the server you are currently using is not in the above list, it is quite simple to implement similar functionality yourself</strong></p>
<h1><a class="header" href="#warp" id="warp">Warp</a></h1>
<p>For <code>Async-graphql-warp</code>, two <code>Filter</code> integrations are provided: <code>graphql</code> and <code>graphql_subscription</code>.</p>
<p>The <code>graphql</code> filter is used for execution <code>Query</code> and <code>Mutation</code> requests. It always asks for the POST method and outputs a <code>Schema</code> via <code>QueryBuilder</code>. You can combine other filters later, or directly call <code>QueryBuilder::execute</code> to execute the query.</p>
<p><code>graphql_subscription</code> is used to implement WebSocket subscriptions. It outputs <code>warp::Reply</code>.</p>
<h2><a class="header" href="#request-example" id="request-example">Request example</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let schema = Schema::new(QueryRoot, EmptyMutation, EmptySubscription);
let filter = async_graphql_warp::graphql(schema).and_then(|(schema, builder): (_, QueryBuilder)| async move {
    // Execute query
    let resp = builder.execute(&amp;schema).await;

    // Return result
    Ok::&lt;_, Infallible&gt;(warp::reply::json(&amp;GQLResponse(resp)).into_response())
});
warp::serve(filter).run(([0, 0, 0, 0], 8000)).await;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#subscription-example" id="subscription-example">Subscription example</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let schema = Schema::new(QueryRoot, EmptyMutation, SubscriptionRoot);
let filter = async_graphql_warp::graphql_subscription(schema);
warp::serve(filter).run(([0, 0, 0, 0], 8000)).await;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#actix-web" id="actix-web">Actix-web</a></h1>
<p><code>Async-graphql-actix-web</code> provides an implementation of <code>actix_web::FromRequest</code> for <code>GQLRequest</code>. This is actually an abstraction around <code>QueryBuilder</code> and you can call <code>GQLRequest::into_inner</code> to convert it into a <code>QueryBuilder</code>。</p>
<p><code>WSSubscription</code> is an Actor that supports WebSocket subscriptions。</p>
<h2><a class="header" href="#request-example-1" id="request-example-1">Request example</a></h2>
<p>When you define your <code>actix_web::App</code> you need to pass in the Schema as data. </p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>async fn index(
    // Schema now accessible here
    schema: web::Data&lt;Schema&gt;,
    gql_request: GQLRequest,
) -&gt; web::Json&lt;GQLResponse&gt; {
    web::Json(GQLResponse(gql_request.into_inner().execute(&amp;schema).await))
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#subscription-example-1" id="subscription-example-1">Subscription example</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>async fn index_ws(
    schema: web::Data&lt;Schema&gt;,
    req: HttpRequest,
    payload: web::Payload,
) -&gt; Result&lt;HttpResponse&gt; {
    ws::start_with_protocols(WSSubscription::new(&amp;schema), &amp;[&quot;graphql-ws&quot;], &amp;req, payload)
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#advanced-topics" id="advanced-topics">Advanced topics</a></h1>
<h1><a class="header" href="#custom-scalars" id="custom-scalars">Custom scalars</a></h1>
<p>In <code>Async-GraphQL</code> most common scalar types are built in, but you can also create your own scalar types.</p>
<p>Using <code>async-graphql::Scalar</code>, you can add support for a scalar when you implement it. You only need to implement parsing and output functions.</p>
<p>The following example defines a 64-bit integer scalar where its input and output are strings. (Note: <code>Async-graphQL</code> already supports 64-bit integers and uses strings as input and output.)</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;


struct StringNumber(i64);

#[Scalar]
impl ScalarType for StringNumber {
    fn type_name() -&gt; &amp;'static str {
        // Name of type
        &quot;StringNumber&quot;
    }

    fn parse(value: &amp;Value) -&gt; InputValueResult&lt;Self&gt; {
        if let Value::String(value) = value {
            // Parse the integer value
            value.parse().map(StringNumber)?
        } else {
            // If the type does not match
            InputValueError::ExpectedType
        }
    }

    fn to_json(&amp;self) -&gt; Result&lt;serde_json::Value&gt; {
        Ok(serde_json::to_value(self.0).unwrap())
    }
}

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#custom-extensions" id="custom-extensions">Custom extensions</a></h1>
<p>A GraphQL extension object can receive events in various stages of a query's execution, and you can collect various kinds of data to be returned in the query results.</p>
<p>You can use <code>async_graphql::Extension</code> to define an extension object, and your application much call <code>Schema::extension</code> when your <code>Schema</code> is created.</p>
<p>You can refer to <a href="https://github.com/async-graphql/async-graphql/blob/master/src/extensions/tracing.rs">Apollo Tracing</a> to implement your own extension types.</p>
<h1><a class="header" href="#custom-subscription-transport" id="custom-subscription-transport">Custom subscription transport</a></h1>
<h1><a class="header" href="#apollo-federation" id="apollo-federation">Apollo Federation</a></h1>
<p><code>Apollo Federation</code> is a <code>GraphQL</code> API gateway which can combine multiple GraphQL services, allowing each service to implement the subset of the API it is responsible for. You can read more in the <a href="https://www.apollographql.com/docs/apollo-server/federation/introduction">official documentation</a>。</p>
<p><code>Async-GraphQL</code> supports all the functionality of <code>Apollo Federation</code>, but some modifications to your <code>Schema</code> are required.</p>
<ul>
<li>
<p>You can use the <code>extends</code> property declaration on <code>async_graphql::Object</code> and <code>async_graphql::Interface</code> to extend a type offered by another implementing service.</p>
</li>
<li>
<p>The <code>external</code> property declares that a field comes from another service。</p>
</li>
<li>
<p>The <code>provides</code> property indicates the fields provided by a service. </p>
</li>
</ul>
<p>The definition of a root Query type is slighly different. An entity search function must be defined. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Query;

#[Object]
impl Query {
    #[entity]
    async fn find_user_by_id(&amp;self, id: ID) -&gt; User {
        User { id }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is equivalent to:</p>
<pre><code class="language-graphql">type User @key(id: ID!) {
    id: ID!,
}
</code></pre>
<p>For a complete example, refer to: https://github.com/async-graphql/examples/tree/master/federation</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
