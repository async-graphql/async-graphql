<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Async-graphql Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Async-graphql Book">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="typesystem.html"><strong aria-hidden="true">3.</strong> Type System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="define_simple_object.html"><strong aria-hidden="true">3.1.</strong> SimpleObject</a></li><li class="chapter-item expanded "><a href="define_complex_object.html"><strong aria-hidden="true">3.2.</strong> Object</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="context.html"><strong aria-hidden="true">3.2.1.</strong> Context</a></li><li class="chapter-item expanded "><a href="error_handling.html"><strong aria-hidden="true">3.2.2.</strong> Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="define_enum.html"><strong aria-hidden="true">3.3.</strong> Enum</a></li><li class="chapter-item expanded "><a href="define_interface.html"><strong aria-hidden="true">3.4.</strong> Interface</a></li><li class="chapter-item expanded "><a href="define_union.html"><strong aria-hidden="true">3.5.</strong> Union</a></li><li class="chapter-item expanded "><a href="define_input_object.html"><strong aria-hidden="true">3.6.</strong> InputObject</a></li><li class="chapter-item expanded "><a href="default_value.html"><strong aria-hidden="true">3.7.</strong> Default value</a></li></ol></li><li class="chapter-item expanded "><a href="define_schema.html"><strong aria-hidden="true">4.</strong> Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="query_and_mutation.html"><strong aria-hidden="true">4.1.</strong> Query and Mutation</a></li><li class="chapter-item expanded "><a href="subscription.html"><strong aria-hidden="true">4.2.</strong> Subscription</a></li></ol></li><li class="chapter-item expanded "><a href="utilities.html"><strong aria-hidden="true">5.</strong> Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input_value_validators.html"><strong aria-hidden="true">5.1.</strong> Input value validators</a></li><li class="chapter-item expanded "><a href="cache_control.html"><strong aria-hidden="true">5.2.</strong> Cache control</a></li><li class="chapter-item expanded "><a href="cursor_connections.html"><strong aria-hidden="true">5.3.</strong> Cursor connections</a></li><li class="chapter-item expanded "><a href="error_extensions.html"><strong aria-hidden="true">5.4.</strong> Error extensions</a></li><li class="chapter-item expanded "><a href="apollo_tracing.html"><strong aria-hidden="true">5.5.</strong> Apollo Tracing</a></li></ol></li><li class="chapter-item expanded "><a href="integrations.html"><strong aria-hidden="true">6.</strong> Integrations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrations_to_warp.html"><strong aria-hidden="true">6.1.</strong> Warp</a></li><li class="chapter-item expanded "><a href="integrations_to_actix_web.html"><strong aria-hidden="true">6.2.</strong> Actix-web</a></li></ol></li><li class="chapter-item expanded "><a href="advanced_topics.html"><strong aria-hidden="true">7.</strong> Advanced topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom_scalars.html"><strong aria-hidden="true">7.1.</strong> Custom scalars</a></li><li class="chapter-item expanded "><a href="custom_extensions.html"><strong aria-hidden="true">7.2.</strong> Custom extensions</a></li><li class="chapter-item expanded "><a href="custom_subscription_transport.html"><strong aria-hidden="true">7.3.</strong> Custom subscription transport</a></li><li class="chapter-item expanded "><a href="apollo_federation.html"><strong aria-hidden="true">7.4.</strong> Apollo Federation</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Async-graphql Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p><code>Async-graphql</code> is a GraphQL server-side library implemented in Rust. It is fully compatible with the GraphQL specification and most of its extensions, and offers type safety and high performance.</p>
<p>You can define a Schema in Rust and procedural macros will automatically generate code for a GraphQL query. This library does not extend Rust's syntax, which means that Rustfmt can be used normally. I value this highly and it is one of the reasons why I developed <code>Async-graphql</code>.</p>
<h2><a class="header" href="#why-do-this" id="why-do-this">Why do this?</a></h2>
<p>I like GraphQL and Rust. I've been using <code>Juniper</code>, which solves the problem of implementing a GraphQL server with Rust. But Juniper had several problems, the most important of which is that it didn't support async/await at the time. So I decided to make this library for myself.</p>
<h2><a class="header" href="#stability-unstable--experimental" id="stability-unstable--experimental">Stability: Unstable &amp; Experimental</a></h2>
<p><strong>This project doesn't currently follow <a href="https://semver.org/">Semantic Versioning (SemVer)</a>, and there can be breaking changes on any version numbers. We will begin following SemVer once the project reaches <code>v2.0.0</code></strong></p>
<p>Even though this project is above <code>v1.0.0</code>, we are rapidly changing and improving the API. This has caused versioning problems that aren't easily resolved because the project became popular very quickly (it was only started in March 2020).</p>
<p>We currently plan to start following SemVer once we reach the <code>v2.0.0</code> release, which will happen once the API starts to stabilize. Unfortunately, we don't currently have the timeline for this.</p>
<p>In accordance with Rust's policy on pre-<code>1.0.0</code> crates, we will try to keep breaking changes limited to minor version changes, but if things don't seem to be compiling after an upgrade, it is likely you'll need to dive into compiler errors to update some syntax that changed. Feel free to open an <a href="https://github.com/async-graphql/async-graphql/issues">issue</a> if something seems weird!</p>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<p>If you are just getting started, we recommend checking out our examples at:
<a href="https://github.com/async-graphql/examples">https://github.com/async-graphql/examples</a></p>
<p>To see how you would create a Relay-compliant server using async-graphql, warp, diesel &amp; postgresql, you can also check out a real-world example at:
<a href="https://github.com/phated/twentyfive-stars">https://github.com/phated/twentyfive-stars</a></p>
<h2><a class="header" href="#benchmarks" id="benchmarks">Benchmarks</a></h2>
<p>Ensure that there is no CPU-heavy process in background!</p>
<pre><code class="language-shellscript">cd benchmark
cargo bench
</code></pre>
<p>Now HTML report is available at <code>benchmark/target/criterion/report</code></p>
<h1><a class="header" href="#quickstart" id="quickstart">Quickstart</a></h1>
<h2><a class="header" href="#add-dependency-libraries" id="add-dependency-libraries">Add dependency libraries</a></h2>
<pre><code class="language-toml">[dependencies]
async-graphql = &quot;1.11.0&quot;
async-graphql-actix-web = &quot;1.3.0&quot; # If you need to integrate into actix-web
async-graphql-warp = &quot;1.3.0&quot; If you need to integrate into warp
async-graphql-tide = &quot;1.2.0&quot; # If you need to integrate into tide
</code></pre>
<h2><a class="header" href="#write-a-schema" id="write-a-schema">Write a Schema</a></h2>
<p>The Schema of a GraphQL contains a required Query, an optional Mutation, and an optional Subscription. These object types are described using the structure of the Rust language. The field of the structure corresponds to the field of the GraphQL object, but you need to mark it with <code>#[field]</code> so that the procedure macro provided by <code>Async-graphql</code> can correctly recognize it.</p>
<p><code>Async-graphql</code> implements the mapping of common data types to GraphQL types, such as <code>i32</code>, <code>f64</code>, <code>Option&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, etc. Also, you can <a href="custom_scalars.html">extend these base types</a>, which are called scalars in the GraphQL.</p>
<p>Here is a simple example where we provide just one query that returns the sum of <code>a</code> and <code>b</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    #[field(desc = &quot;Returns the sum of a and b&quot;)]
    async fn add(&amp;self, a: i32, b: i32) -&gt; i32 {
        a + b
    }
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#execute-the-query" id="execute-the-query">Execute the query</a></h2>
<p>In our example, there is only Query without Mutation and Subscription, so we create the Schema with <code>EmptyMutation</code> and <code>EmptySubscription</code>, and then call <code>Schema::execute</code> to execute the Query.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let schema = Schema::new(Query, EmptyMutation, EmptySubscription);
let res = schema.execute(&quot;{ add(a: 10, b: 20) }&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#output-the-query-results-as-json" id="output-the-query-results-as-json">Output the query results as JSON</a></h2>
<p>Query returns <code>async_graphql::Result</code> with <code>async_graphql::http::GQLResponse </code> wrapped, can be directly converted to JSON.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let json = serde_json::to_string(&amp;async_graphql::http::GQLResponse(res));
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#web-server-integration" id="web-server-integration">Web server integration</a></h2>
<p>Please refer to https://github.com/async-graphql/examples.</p>
<h1><a class="header" href="#type-system" id="type-system">Type System</a></h1>
<p><code>Async-graphql</code> implemented conversion from GraphQL Object to Rust struct, and it's easy to use.</p>
<h1><a class="header" href="#simpleobject" id="simpleobject">SimpleObject</a></h1>
<p><code>SimpleObject</code> directly map all field of a struct to GraphQL object, you cannot define a resolver function on it.</p>
<p>The example below defined an object <code>MyObject</code>, including field <code>a</code> and <code>b</code>. <code>c</code> will be not mapped to GraphQL as it is labelled as <code>#[field(skip)]</code></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

#[SimpleObject]
struct MyObject {
    a: i32,
    b: i32,

    #[field(skip)]
    c: i32,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#object" id="object">Object</a></h1>
<p>Different from <code>SimpleObject</code>, <code>Object</code> must have Resolve defined for each field in <code>impl</code>.</p>
<p><strong>A resolver function has to be asynchronous. The first argument has to be <code>&amp;self</code>, second being optional <code>Context</code> and followed by field arguments.</strong></p>
<p>Resolve is used to get the value of the field. You can query a database and return the result. <strong>The return type of the function is the type of the field.</strong> You can also return a <code>async_graphql::FieldResult</code> so to return an error if it occurs an error message will be sent to query result.</p>
<p>When querying a database, you may need a global data base connection pool.
When creating <code>Schema</code>,  you can use <code>SchemaBuilder::data</code> to setup <code>Schema</code> data, and <code>Context::data</code> to setup <code>Context</code>data.
The following <code>value_from_db</code> function showed how to retrieve a database connection from <code>Context</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct MyObject {
    value: i32,
}

#[Object]
impl MyObject {
    async fn value(&amp;self) -&gt; String {
        self.value.to_string()
    }

    async fn value_from_db(
        &amp;self,
        ctx: &amp;Context&lt;'_&gt;,
        #[arg(desc = &quot;Id of object&quot;)] id: i64
    ) -&gt; FieldResult&lt;String&gt; {
        let conn = ctx.data::&lt;DbPool&gt;().take();
        Ok(conn.query_something(id)?.name)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#context" id="context">Context</a></h1>
<p>The main goal of <code>Context</code> is to acquire global data attached to Schema. <strong>Note that if the return value of resolver function is borrowed from <code>Context</code>, you need to explicitly state the lifetime of the argument.</strong></p>
<p>The following example shows how to borrow data in <code>Context</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    async fn borrow_from_context_data&lt;'ctx'&gt;(
        &amp;self,
        ctx: &amp;'ctx Context&lt;'_&gt;
    ) -&gt; &amp;'ctx String {
        ctx.data::&lt;String&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#error-handling" id="error-handling">Error handling</a></h1>
<p>Resolve can return a <code>FieldResult</code>, following is the definition:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type FieldResult&lt;T&gt; = std::result::Result&lt;T, FieldError&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Any <code>Error</code> that implements <code>std::fmt::Display</code> can be converted to <code>FieldError</code> and you can extend error message.</p>
<p>Following example shows how to parse an input string to integer. When parsing failed, it would return error and attach error message.
See <a href="error_extensions.html">ErrorExtensions</a> sections of this book for more details.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    #[field]
    async fn parse_with_extensions(&amp;self, input: String) -&gt; FieldResult&lt;i32&gt; {
        Ok(&quot;234a&quot;
            .parse()
            .map_err(|err: ParseIntError| err.extend_with(|_| json!({&quot;code&quot;: 400})))?)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#enum" id="enum">Enum</a></h1>
<p>It's easy to define an <code>Enum</code>, here we have an example:</p>
<p><strong>Async-graphql can automatically change the name of each item to GraphQL's CONSTANT_CASE convension, you can also use <code>name</code> to rename.</strong></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

#[Enum(desc = &quot;One of the films in the Star Wars Trilogy&quot;)]
pub enum Episode {
    #[item(desc = &quot;Released in 1977.&quot;)]
    NewHope,

    #[item(desc = &quot;Released in 1980.&quot;)]
    Empire,

    // rename to `AAA`
    #[item(name=&quot;AAA&quot;, desc = &quot;Released in 1983.&quot;)]
    Jedi,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#interface" id="interface">Interface</a></h1>
<p><code>Interface</code> is used to abstract <code>Object</code>s with common fields.
<code>Async-graphql</code> implemented it as a wrapper.
The wrapper will forward Resolve to the <code>Object</code> that implemented this <code>Interface</code>.
Therefore, the <code>Object</code>'s fields' type, arguments must match with the <code>Interface</code>'s.</p>
<p><code>Async-graphql</code> implemented auto conversion from <code>Object</code> to <code>Interface</code>, you only need to call <code>Into::into</code>.</p>
<p>Interface fields names transforms to camelCase in schema definition.
If you need e.g. snake_cased GraphQL field name, you can use both the <code>name</code> and <code>method</code> attribute.</p>
<ul>
<li>When the <code>name</code> and <code>method</code> exist together, the <code>name</code> is the GraphQL field name and the <code>method</code> is the resolver function name.</li>
<li>When only <code>name</code> exists, <code>name.to_camel_case()</code> is the GraphQL field name and the <code>name</code> is the resolver function name.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Circle {
    radius: f32,
}

#[Object]
impl Circle {
    async fn area(&amp;self) -&gt; f32 {
        std::f32::consts::PI * self.radius * self.radius
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Circle { radius: self.radius * s }.into()
    }

    #[field(name = &quot;short_description&quot;)]
    async fn short_description(&amp;self) -&gt; String {
        &quot;Circle&quot;.to_string()
    }
}

struct Square {
    width: f32,
}

#[Object]
impl Square {
    async fn area(&amp;self) -&gt; f32 {
        self.width * self.width
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Square { width: self.width * s }.into()
    }

    #[field(name = &quot;short_description&quot;)]
    async fn short_description(&amp;self) -&gt; String {
        &quot;Square&quot;.to_string()
    }
}

#[Interface(
    field(name = &quot;area&quot;, type = &quot;f32&quot;),
    field(name = &quot;scale&quot;, type = &quot;Shape&quot;, arg(name = &quot;s&quot;, type = &quot;f32&quot;))
    field(name = &quot;short_description&quot;, method = &quot;short_description&quot;, type = &quot;String&quot;)
)]
enum Shape {
    Circle(Circle),
    Square(Square),
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#union" id="union">Union</a></h1>
<p>The definition of <code>Union</code> is similar to <code>Interface</code>'s, <strong>but no field allowed.</strong>.
The implemention is quite similar for <code>Async-graphql</code>.
From <code>Async-graphql</code>'s perspective, <code>Union</code> is a subset of <code>Interface</code>.</p>
<p>The following example modified the definition of <code>Interface</code> a little bit and removed fields.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Circle {
    radius: f32,
}

#[Object]
impl Circle {
    async fn area(&amp;self) -&gt; f32 {
        std::f32::consts::PI * self.radius * self.radius
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Circle { radius: self.radius * s }.into()
    }
}

struct Square {
    width: f32,
}

#[Object]
impl Square {
    async fn area(&amp;self) -&gt; f32 {
        self.width * self.width
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Square { width: self.width * s }.into()
    }
}

#[Union]
enum Shape {
    Circle(Circle),
    Square(Square),
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#inputobject" id="inputobject">InputObject</a></h1>
<!--Input Object and SimpleObject inconsistant space.-->
<p>You can define an <code>Object</code> as argument, GraphQL calls it <code>InputObject</code>.
The definition of <code>InputObject</code> is similar to <a href="define_simple_object.html">SimpleObject</a>.
However, <code>SimpleObject</code> can only be used for output and <code>InputObject</code> can only be used as input.</p>
<p><code>InputObject</code> don't need a <code>#[field]</code> for each field, every field is <code>InputValue</code>.
But you can add optional <code>#[field]</code> to add description or rename the field.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

#[InputObject]
struct Coordinate {
    latitude: f64,

    #[field(desc = &quot;...&quot;)]
    longitude: f64
}

struct Mutation;

#[Object]
impl Mutation {
    async fn users_at_location(&amp;self, coordinate: Coordinate, radius: f64) -&gt; Vec&lt;User&gt; {
        // Writes coordination to database.
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#default-value" id="default-value">Default value</a></h1>
<p>You can define default values for input value types.
The following shows how to define default values for different types.</p>
<h2><a class="header" href="#object-field" id="object-field">Object field</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

fn my_default() -&gt; i32 {
    30
}

#[Object]
impl Query {
    // The default value of the value parameter is 0, it will call i32::default()
    fn test1(&amp;self, #[arg(default)] value: i32) {}
    
    // The default value of the value parameter is 10
    fn test2(&amp;self, #[arg(default = 10)] value: i32) {}

    // The default value of the value parameter uses the return result of the my_default function, the value is 30.
    fn test3(&amp;self, #[arg(default_with = &quot;my_default()&quot;)] value: i32) {}
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#interface-field" id="interface-field">Interface field</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

#[Interface(
    field(name = &quot;test1&quot;, arg(name = &quot;value&quot;, default)),
    field(name = &quot;test2&quot;, arg(name = &quot;value&quot;, default = 10)),
    field(name = &quot;test3&quot;, arg(name = &quot;value&quot;, default = &quot;my_default()&quot;)),
)]
enum MyInterface {
    MyObj(MyObj),
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#input-object-field" id="input-object-field">Input object field</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct MyInputObject {
    #[field(default)]
    value1: i32,
    
    #[field(default = 10)]
    value2: i32,

    #[field(default = &quot;my_default()&quot;)]
    value3: i32,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#schema" id="schema">Schema</a></h1>
<p>After defining the basic types, you need to define a schema to combine them. The schema consists of three types: a query object, mutation object, and subscription object, where the mutation object and subscription object are optional.</p>
<p>When the schema is created, <code>Async-Graphql</code> will traverse all object graphs and register all types. This means that if a GraphQL object is defined but never referenced, then this object will not be exposed in the schema.</p>
<h1><a class="header" href="#query-and-mutation" id="query-and-mutation">Query and Mutation</a></h1>
<h2><a class="header" href="#query-root-object" id="query-root-object">Query root object</a></h2>
<p>The query root object is a GraphQL object with a definition similar to other objects. resolver functions for all fields of the query object are executed concurrently.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    async fn user(&amp;self, username: String) -&gt; FieldResult&lt;Option&lt;User&gt;&gt; {
        // Look up users from the database
    }
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#mutation-root-object" id="mutation-root-object">Mutation root object</a></h2>
<p>The mutation root object is also a GraphQL object, but it executes sequentially. One mutation following from another will only be executed only after the first mutation is completed.</p>
<p>The following mutation root object provides an example of user registration and login:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Mutation;

#[Object]
impl Mutation {
    async fn signup(&amp;self, username: String, password: String) -&gt; Result&lt;bool&gt; {
        // User signup
    }

    async fn login(&amp;self, username: String, password: String) -&gt; Result&lt;String&gt; {
        // User login (generate token)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#subscription" id="subscription">Subscription</a></h1>
<p>The definition of the subscription root object is slightly different from other root objects. Its resolver function always returns a Stream, and the field parameters are usually used as data filtering conditions.</p>
<p>The following example subscribes to an integer stream, which generates one integer per second. The parameter step specifies the integer step size with a default of 1</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;

struct Subscription;

#[Subscription]
impl Subscription {
    async fn integers(&amp;self, #[arg(default = &quot;1&quot;)] step: i32) -&gt; impl Stream&lt;Item = i32&gt; {
        let mut value = 0;
        tokio::time::interval(Duration::from_secs(1)).map(move |_| {
            value += step;
            value
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#utilities" id="utilities">Utilities</a></h1>
<h1><a class="header" href="#input-value-validators" id="input-value-validators">Input value validators</a></h1>
<p>Arguments to a query (<a href="define_input_object.html">InputObject</a>) are called <code>Input Objects</code> in GraphQL. If the provided input type does not match for a query, the query will return a type mismatch error. But sometimes we want to provide more restrictions on specific types of values. For example, we might want to require that an argument is a valid email address. Async-graphql provides an input validators to solve this problem.</p>
<p>An input validator can be combined via <code>and</code> and <code>or</code> operators.</p>
<p>The following is an input validator which checks that a <code>String</code> is a valid Email or MAC address:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
use async_graphql::validators::{Email, MAC};

struct Query;

#[Object]
impl Query {
    async fn input(#[arg(validator(or(Email, MAC(colon = &quot;false&quot;))))] a: String) {
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The following example verifies that the <code>i32</code> parameter <code>a</code> is greater than 10 and less than 100, or else equal to 0:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql:*;
use async_graphql::validators::{IntGreaterThan, IntLessThan, IntEqual};

struct Query;

#[Object]
impl Query {
    async fn input(#[validator(
        or(
            and(IntGreaterThan(value = &quot;10&quot;), IntLessThan(value = &quot;100&quot;)),
            IntEqual(value = &quot;0&quot;)
        ))] a: String) {
    } {
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#custom-validator" id="custom-validator">Custom validator</a></h2>
<p>Here is an example of a custom validator:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct MustBeZero {}

impl InputValueValidator for InputValueValidator {
    fn is_valid(&amp;self, value: &amp;Value) -&gt; Option&lt;String&gt; {
        if let Value::Int(n) = value {
            if n.as_i64().unwrap() != 0 {
                // Validation failed
                Some(format!(
                    &quot;the value is {}, but must be zero&quot;,
                    n.as_i64().unwrap(),
                ))
            } else {
                // Validation succeeded
                None
            }
        } else {
            // If the type does not match we can return None and built-in validations
            // will pick up on the error
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#cache-control" id="cache-control">Cache control</a></h1>
<p>Production environments often rely on caching to improve performance.</p>
<p>A GraphQL query will call multiple resolver functions and each resolver can have a different cache definition. Some may cache for a few seconds, some may cache for a few hours, some may be the same for all users, and some may be different for each session.</p>
<p><code>Async-Graphql</code> provides a mechanism that allows you to define the cache time and scope for each resolver.</p>
<p>You can define cache parameters on the object or on its fields. The following example shows two uses of cache control parameters.</p>
<p>You can use <code>max_age</code> parameters to control the age of the cache (in seconds), and you can also use <code>public</code> and <code>private</code> to control the scope of the cache. When you do not specify it, the scope will default to <code>public</code>.</p>
<p>lWhen querying multiple resolvers, the results of all cache control parameters will be combined and the <code>max_age</code> minimum value will be taken. If the scope of any object or field is <code>private</code>, the result will be <code>private</code>.</p>
<p>We can use <code>QueryResponse</code> to get a merged cache control result from a query result, and call <code>CacheControl::value</code> to get the corresponding HTTP header.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[Object(cache_control(max_age = 60))]
impl Query {
    #[field(cache_control(max_age = 30))]
    async fn value1(&amp;self) -&gt; i32 {
    }

    #[field(cache_control(private))]
    async fn value2(&amp;self) -&gt; i32 {
    }

    async fn value3(&amp;self) -&gt; i32 {
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The following are different queries corresponding to different cache control results:</p>
<pre><code class="language-graphql"># max_age=30
{ value1 }
</code></pre>
<pre><code class="language-graphql"># max_age=30, private
{ value1 value2 }
</code></pre>
<pre><code class="language-graphql"># max_age=60
{ value3 }
</code></pre>
<h1><a class="header" href="#cursor-connections" id="cursor-connections">Cursor connections</a></h1>
<p>Relay's cursor connection specification is defined to provide a consistent method for query paging. For more details on the specification see the <a href="https://facebook.github.io/relay/graphql/connections.htm">GraphQL Cursor Connections Specification</a>ã€‚</p>
<p>Define a cursor connection in <code>async-graphql</code> is very simple, you just call the <code>connection::query</code> function and query data in closure.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
use async_graphql::connection::*;

struct Query;

#[Object]
impl Query {
    #[field]
    async fn numbers(&amp;self,
        after: Option&lt;String&gt;,
        before: Option&lt;String&gt;,
        first: Option&lt;i32&gt;,
        last: Option&lt;i32&gt;,
    ) -&gt; FieldResult&lt;Connection&lt;usize, i32, EmptyFields, EmptyFields&gt;&gt; {
        query(after, before, first, last, |after, before, first, last| {
            let mut start = after.map(|after| after + 1).unwrap_or(0);
            let mut end = before.unwrap_or(10000);
            if let Some(first) = first {
                end = (start + first).min(end);
            }
            if let Some(last) = last {
                start = if last &gt; end - start {
                     end
                } else {
                    end - last
                };
            }
            let mut connection = Connection::new(start &gt; 0, end &lt; 10000);
            connection.append(
                (start..end).into_iter().map(|n|
                    Ok(Edge::new_with_additional_fields(n, n as i32, EmptyFields)),
            ))?;
            Ok(connection)
        })
    }
}

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#error-extensions" id="error-extensions">Error extensions</a></h1>
<p>To quote the <a href="https://spec.graphql.org/June2018/#example-fce18">graphql-spec</a>:</p>
<blockquote>
<p>GraphQL services may provide an additional entry to errors with key extensions.
This entry, if set, must have a map as its value. This entry is reserved for implementors to add
additional information to errors however they see fit, and there are no additional restrictions on
its contents.</p>
</blockquote>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>I would recommend on checking out this <a href="https://github.com/async-graphql/examples/blob/master/actix-web/error-extensions/src/main.rs">async-graphql example</a> as a quickstart.</p>
<h2><a class="header" href="#general-concept" id="general-concept">General Concept</a></h2>
<p>In async-graphql all user-facing errors are cast to the <code>FieldError</code> type which by default provides
the error message exposed by <code>std::fmt::Display</code>. However <code>FieldError</code> actually provides an additional
field <code>Option&lt;serde_json::Value&gt;</code> which - if some valid <code>serde_json::Map</code> - will be exposed as the extensions key to any error.</p>
<p>A resolver like this: </p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>async fn parse_with_extensions(&amp;self) -&gt; Result&lt;i32, FieldError&gt; {
    let my_extension = json!({ &quot;details&quot;: &quot;CAN_NOT_FETCH&quot; });
    Err(FieldError(&quot;MyMessage&quot;, Some(my_extension)))
 }
<span class="boring">}
</span></code></pre></pre>
<p>may then return a response like this:</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;MyMessage&quot;,
      &quot;locations&quot;: [ ... ],
      &quot;path&quot;: [ ... ],
      &quot;extensions&quot;: {
        &quot;details&quot;: &quot;CAN_NOT_FETCH&quot;,
      }
    }
  ]
}
</code></pre>
<h2><a class="header" href="#errorextensions" id="errorextensions">ErrorExtensions</a></h2>
<p>Constructing new <code>FieldError</code>s by hand quickly becomes tedious. That is why async_graphql provides
two convenience traits for casting your errors to the appropriate <code>FieldError</code> with
extensions.</p>
<p>The easiest way to provide extensions to any error is by calling <code>extend_with</code> on the error.
This will on the fly convert any error into a <code>FieldError</code> with the given extension.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::num::ParseIntError;
async fn parse_with_extensions(&amp;self) -&gt; FieldResult&lt;i32&gt; {
     Ok(&quot;234a&quot;
         .parse()
         .map_err(|err: ParseIntError| err.extend_with(|_err| json!({&quot;code&quot;: 404})))?)
 }
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#implementing-errorextensions-for-custom-errors" id="implementing-errorextensions-for-custom-errors">Implementing ErrorExtensions for custom errors.</a></h3>
<p>If you find yourself attaching extensions to your errors all over the place you might want to consider
implementing the trait on your custom error type directly.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[macro_use]
extern crate thiserror;

#[derive(Debug, Error)]
pub enum MyError {
    #[error(&quot;Could not find resource&quot;)]
    NotFound,

    #[error(&quot;ServerError&quot;)]
    ServerError(String),

    #[error(&quot;No Extensions&quot;)]
    ErrorWithoutExtensions,
}

impl ErrorExtensions for MyError {
    // lets define our base extensions
    fn extend(&amp;self) -&gt; FieldError {
        let extensions = match self {
            MyError::NotFound =&gt; json!({&quot;code&quot;: &quot;NOT_FOUND&quot;}),
            MyError::ServerError(reason) =&gt; json!({ &quot;reason&quot;: reason }),
            MyError::ErrorWithoutExtensions =&gt; {
                json!(&quot;This will be ignored since it does not represent an object.&quot;)
            }
        };

        FieldError(format!(&quot;{}&quot;, self), Some(extensions))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This way you only need to call <code>extend</code> on your error to deliver the error message alongside the provided extensions.
Or further extend your error through <code>extend_with</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>async fn parse_with_extensions_result(&amp;self) -&gt; FieldResult&lt;i32&gt; {
    // Err(MyError::NotFound.extend())
    // OR
    Err(MyError::NotFound.extend_with(|_| json!({ &quot;on_the_fly&quot;: &quot;some_more_info&quot; })))
}

<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;NotFound&quot;,
      &quot;locations&quot;: [ ... ],
      &quot;path&quot;: [ ... ],
      &quot;extensions&quot;: {
        &quot;code&quot;: &quot;NOT_FOUND&quot;,
        &quot;on_the_fly&quot;: &quot;some_more_info&quot;
      }
    }
  ]
}

</code></pre>
<h2><a class="header" href="#resultext" id="resultext">ResultExt</a></h2>
<p>This trait enables you to call <code>extend_err</code> directly on results. So the above code becomes less verbose.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
async fn parse_with_extensions(&amp;self) -&gt; FieldResult&lt;i32&gt; {
     Ok(&quot;234a&quot;
         .parse()
         .extend_err(|_| json!({&quot;code&quot;: 404}))?)
 }

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#chained-extensions" id="chained-extensions">Chained extensions</a></h3>
<p>Since <code>ErrorExtensions</code> and <code>ResultExt</code> are implemented for any type <code>&amp;E where E: std::fmt::Display</code>
we can chain the extension together.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
async fn parse_with_extensions(&amp;self) -&gt; FieldResult&lt;i32&gt; {
    match &quot;234a&quot;.parse() {
        Ok(n) =&gt; Ok(n),
        Err(e) =&gt; Err(e
            .extend_with(|_| json!({&quot;code&quot;: 404}))
            .extend_with(|_| json!({&quot;details&quot;: &quot;some more info..&quot;}))
            // keys may also overwrite previous keys...
            .extend_with(|_| json!({&quot;code&quot;: 500}))),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Expected response:</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;MyMessage&quot;,
      &quot;locations&quot;: [ ... ],
      &quot;path&quot;: [ ... ],
      &quot;extensions&quot;: {
      	&quot;details&quot;: &quot;some more info...&quot;,
        &quot;code&quot;: 500,
      }
    }
  ]
}
</code></pre>
<h3><a class="header" href="#pitfalls" id="pitfalls">Pitfalls</a></h3>
<p>Rust does not provide stable trait specialization yet.
That is why <code>ErrorExtensions</code> is actually implemented for <code>&amp;E where E: std::fmt::Display</code>
instead of <code>E: std::fmt::Display</code> to provide some specialization through
<a href="https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md">Autoref-based stable specialization</a>.
The disadvantage is that the below code does <strong>NOT</strong> compile:</p>
<pre><code class="language-rust ignore does_not_compile">async fn parse_with_extensions_result(&amp;self) -&gt; FieldResult&lt;i32&gt; {
    // the trait `error::ErrorExtensions` is not implemented
    // for `std::num::ParseIntError`
    &quot;234a&quot;.parse().extend_err(|_| json!({&quot;code&quot;: 404}))
}
</code></pre>
<p>however this does:</p>
<pre><code class="language-rust ignore does_not_compile">async fn parse_with_extensions_result(&amp;self) -&gt; FieldResult&lt;i32&gt; {
    // does work because ErrorExtensions is implemented for &amp;ParseIntError
    &quot;234a&quot;
      .parse()
      .map_err(|ref e: ParseIntError| e.extend_with(|_| json!({&quot;code&quot;: 404})))
}
</code></pre>
<h1><a class="header" href="#apollo-tracing" id="apollo-tracing">Apollo Tracing</a></h1>
<p>Apollo Tracing provides performance analysis results for each step of query. This is an extension to <code>Schema</code>, and the performance analysis results are stored in <code>QueryResponse</code>.</p>
<p>To enable the Apollo Tracing extension, add the extension when a <code>Schema</code> is created.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;
use async_graphql::extensions::ApolloTracing;

let schema = Schema::build(Query, EmptyMutation, EmptySubscription)
    .extension(|| ApolloTracing::default()) // Enable ApolloTracing extension
    .finish();

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#integrations" id="integrations">Integrations</a></h1>
<p><code>Async-Graphql</code> supports several common Rust web servers.</p>
<ul>
<li>Actix-web <a href="https://crates.io/crates/async-graphql-actix-web">async-graphql-actix-web</a></li>
<li>Warp <a href="https://crates.io/crates/async-graphql-warp">async-graphql-warp</a></li>
</ul>
<p><strong>Even if the server you are currently using is not in the above list, it is quite simple to implement similar functionality yourself</strong></p>
<h1><a class="header" href="#warp" id="warp">Warp</a></h1>
<p>For <code>Async-graphql-warp</code>, two <code>Filter</code> integrations are provided: <code>graphql</code> and <code>graphql_subscription</code>.</p>
<p>The <code>graphql</code> filter is used for execution <code>Query</code> and <code>Mutation</code> requests. It always asks for the POST method and outputs a <code>Schema</code> via <code>QueryBuilder</code>. You can combine other filters later, or directly call <code>QueryBuilder::execute</code> to execute the query.</p>
<p><code>graphql_subscription</code> is used to implement WebSocket subscriptions. It outputs <code>warp::Reply</code>.</p>
<h2><a class="header" href="#request-example" id="request-example">Request example</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let schema = Schema::new(QueryRoot, EmptyMutation, EmptySubscription);
let filter = async_graphql_warp::graphql(schema).and_then(|(schema, builder): (_, QueryBuilder)| async move {
    // Execute query
    let resp = builder.execute(&amp;schema).await;

    // Return result
    Ok::&lt;_, Infallible&gt;(warp::reply::json(&amp;GQLResponse(resp)).into_response())
});
warp::serve(filter).run(([0, 0, 0, 0], 8000)).await;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#subscription-example" id="subscription-example">Subscription example</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let schema = Schema::new(QueryRoot, EmptyMutation, SubscriptionRoot);
let filter = async_graphql_warp::graphql_subscription(schema);
warp::serve(filter).run(([0, 0, 0, 0], 8000)).await;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#actix-web" id="actix-web">Actix-web</a></h1>
<p><code>Async-graphql-actix-web</code> provides an implementation of <code>actix_web::FromRequest</code> for <code>GQLRequest</code>. This is actually an abstraction around <code>QueryBuilder</code> and you can call <code>GQLRequest::into_inner</code> to convert it into a <code>QueryBuilder</code>ã€‚</p>
<p><code>WSSubscription</code> is an Actor that supports WebSocket subscriptionsã€‚</p>
<h2><a class="header" href="#request-example-1" id="request-example-1">Request example</a></h2>
<p>When you define your <code>actix_web::App</code> you need to pass in the Schema as data. </p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>async fn index(
    // Schema now accessible here
    schema: web::Data&lt;Schema&gt;,
    gql_request: GQLRequest,
) -&gt; web::Json&lt;GQLResponse&gt; {
    web::Json(GQLResponse(gql_request.into_inner().execute(&amp;schema).await))
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#subscription-example-1" id="subscription-example-1">Subscription example</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>async fn index_ws(
    schema: web::Data&lt;Schema&gt;,
    req: HttpRequest,
    payload: web::Payload,
) -&gt; Result&lt;HttpResponse&gt; {
    ws::start_with_protocols(WSSubscription::new(&amp;schema), &amp;[&quot;graphql-ws&quot;], &amp;req, payload)
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#advanced-topics" id="advanced-topics">Advanced topics</a></h1>
<h1><a class="header" href="#custom-scalars" id="custom-scalars">Custom scalars</a></h1>
<p>In <code>Async-GraphQL</code> most common scalar types are built in, but you can also create your own scalar types.</p>
<p>Using <code>async-graphql::Scalar</code>, you can add support for a scalar when you implement it. You only need to implement parsing and output functions.</p>
<p>The following example defines a 64-bit integer scalar where its input and output are strings. (Note: <code>Async-graphQL</code> already supports 64-bit integers and uses strings as input and output.)</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use async_graphql::*;


struct StringNumber(i64);

#[Scalar]
impl ScalarType for StringNumber {
    fn parse(value: Value) -&gt; InputValueResult&lt;Self&gt; {
        if let Value::String(value) = value {
            // Parse the integer value
            value.parse().map(StringNumber)?
        } else {
            // If the type does not match
            InputValueError::ExpectedType
        }
    }

    fn to_value(&amp;self) -&gt; Value {
        Value::String(self.0.to_string())
    }
}

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#custom-extensions" id="custom-extensions">Custom extensions</a></h1>
<p>A GraphQL extension object can receive events in various stages of a query's execution, and you can collect various kinds of data to be returned in the query results.</p>
<p>You can use <code>async_graphql::Extension</code> to define an extension object, and your application must call <code>Schema::extension</code> when your <code>Schema</code> is created.</p>
<p>You can refer to <a href="https://github.com/async-graphql/async-graphql/blob/master/src/extensions/tracing.rs">Apollo Tracing</a> to implement your own extension types.</p>
<h1><a class="header" href="#custom-subscription-transport" id="custom-subscription-transport">Custom subscription transport</a></h1>
<h1><a class="header" href="#apollo-federation" id="apollo-federation">Apollo Federation</a></h1>
<p><code>Apollo Federation</code> is a <code>GraphQL</code> API gateway which can combine multiple GraphQL services, allowing each service to implement the subset of the API it is responsible for. You can read more in the <a href="https://www.apollographql.com/docs/apollo-server/federation/introduction">official documentation</a>ã€‚</p>
<p><code>Async-GraphQL</code> supports all the functionality of <code>Apollo Federation</code>, but some modifications to your <code>Schema</code> are required.</p>
<ul>
<li>
<p>You can use the <code>extends</code> property declaration on <code>async_graphql::Object</code> and <code>async_graphql::Interface</code> to extend a type offered by another implementing service.</p>
</li>
<li>
<p>The <code>external</code> property declares that a field comes from another serviceã€‚</p>
</li>
<li>
<p>The <code>provides</code> property indicates the fields provided by a service. </p>
</li>
</ul>
<h2><a class="header" href="#entity-lookup-function" id="entity-lookup-function">Entity lookup function</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Query;

#[Object]
impl Query {
    #[entity]
    async fn find_user_by_id(&amp;self, id: ID) -&gt; User {
        User { ... }
    }

    #[entity]
    async fn find_user_by_id_with_username(&amp;self, #[arg(key)] id: ID, username: String) -&gt; User {
        User { ... }
    }

    #[entity]
    async fn find_user_by_id_and_username(&amp;self, id: ID, username: String) -&gt; User {
        User { ... }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Notice the difference between these three lookup functions, which are all looking for the <code>User</code> object.</strong></p>
<ul>
<li>
<p>find_user_by_id</p>
<p>Use <code>id</code> to find an <code>User</code> object, the key for <code>User</code> is <code>id</code>ã€‚</p>
</li>
<li>
<p>find_user_by_id_with_username</p>
<p>Use <code>id</code> to find an <code>User</code> object, the key for <code>User</code> is <code>id</code>, and the <code>username</code> field value of the <code>User</code> object is requestedã€‚</p>
</li>
<li>
<p>find_user_by_id_and_username</p>
<p>Use <code>id</code> and <code>username</code> to find an <code>User</code> object, the keys for <code>User</code> are <code>id</code> and <code>username</code>ã€‚</p>
</li>
</ul>
<p>For a complete example, refer to: https://github.com/async-graphql/examples/tree/master/federation</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
