<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Async-graphql Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Async-graphql Book">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="typesystem.html"><strong aria-hidden="true">3.</strong> Type System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="define_simple_object.html"><strong aria-hidden="true">3.1.</strong> SimpleObject</a></li><li class="chapter-item expanded "><a href="define_complex_object.html"><strong aria-hidden="true">3.2.</strong> Object</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="context.html"><strong aria-hidden="true">3.2.1.</strong> Context</a></li><li class="chapter-item expanded "><a href="error_handling.html"><strong aria-hidden="true">3.2.2.</strong> Error handling</a></li><li class="chapter-item expanded "><a href="merging_objects.html"><strong aria-hidden="true">3.2.3.</strong> Merging Objects / Subscriptions</a></li><li class="chapter-item expanded "><a href="derived_fields.html"><strong aria-hidden="true">3.2.4.</strong> Derived fields</a></li></ol></li><li class="chapter-item expanded "><a href="define_enum.html"><strong aria-hidden="true">3.3.</strong> Enum</a></li><li class="chapter-item expanded "><a href="define_interface.html"><strong aria-hidden="true">3.4.</strong> Interface</a></li><li class="chapter-item expanded "><a href="define_union.html"><strong aria-hidden="true">3.5.</strong> Union</a></li><li class="chapter-item expanded "><a href="define_input_object.html"><strong aria-hidden="true">3.6.</strong> InputObject</a></li><li class="chapter-item expanded "><a href="define_one_of_object.html"><strong aria-hidden="true">3.7.</strong> OneofObject</a></li><li class="chapter-item expanded "><a href="default_value.html"><strong aria-hidden="true">3.8.</strong> Default value</a></li></ol></li><li class="chapter-item expanded "><a href="define_schema.html"><strong aria-hidden="true">4.</strong> Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="query_and_mutation.html"><strong aria-hidden="true">4.1.</strong> Query and Mutation</a></li><li class="chapter-item expanded "><a href="subscription.html"><strong aria-hidden="true">4.2.</strong> Subscription</a></li><li class="chapter-item expanded "><a href="sdl_export.html"><strong aria-hidden="true">4.3.</strong> SDL Export</a></li></ol></li><li class="chapter-item expanded "><a href="utilities.html"><strong aria-hidden="true">5.</strong> Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="field_guard.html"><strong aria-hidden="true">5.1.</strong> Field guard</a></li><li class="chapter-item expanded "><a href="input_value_validators.html"><strong aria-hidden="true">5.2.</strong> Input value validators</a></li><li class="chapter-item expanded "><a href="cache_control.html"><strong aria-hidden="true">5.3.</strong> Cache control</a></li><li class="chapter-item expanded "><a href="cursor_connections.html"><strong aria-hidden="true">5.4.</strong> Cursor connections</a></li><li class="chapter-item expanded "><a href="error_extensions.html"><strong aria-hidden="true">5.5.</strong> Error extensions</a></li><li class="chapter-item expanded "><a href="apollo_tracing.html"><strong aria-hidden="true">5.6.</strong> Apollo Tracing</a></li><li class="chapter-item expanded "><a href="depth_and_complexity.html"><strong aria-hidden="true">5.7.</strong> Query complexity and depth</a></li><li class="chapter-item expanded "><a href="visibility.html"><strong aria-hidden="true">5.8.</strong> Hide content in introspection</a></li></ol></li><li class="chapter-item expanded "><a href="extensions.html"><strong aria-hidden="true">6.</strong> Extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="extensions_inner_working.html"><strong aria-hidden="true">6.1.</strong> How extensions are working</a></li><li class="chapter-item expanded "><a href="extensions_available.html"><strong aria-hidden="true">6.2.</strong> Available extensions</a></li></ol></li><li class="chapter-item expanded "><a href="integrations.html"><strong aria-hidden="true">7.</strong> Integrations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrations_to_poem.html"><strong aria-hidden="true">7.1.</strong> Poem</a></li><li class="chapter-item expanded "><a href="integrations_to_warp.html"><strong aria-hidden="true">7.2.</strong> Warp</a></li><li class="chapter-item expanded "><a href="integrations_to_actix_web.html"><strong aria-hidden="true">7.3.</strong> Actix-web</a></li></ol></li><li class="chapter-item expanded "><a href="advanced_topics.html"><strong aria-hidden="true">8.</strong> Advanced topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom_scalars.html"><strong aria-hidden="true">8.1.</strong> Custom scalars</a></li><li class="chapter-item expanded "><a href="dataloader.html"><strong aria-hidden="true">8.2.</strong> Optimizing N+1 queries</a></li><li class="chapter-item expanded "><a href="custom_directive.html"><strong aria-hidden="true">8.3.</strong> Custom directive</a></li><li class="chapter-item expanded "><a href="apollo_federation.html"><strong aria-hidden="true">8.4.</strong> Apollo Federation</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Async-graphql Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><code>Async-graphql</code> is a GraphQL server-side library implemented in Rust. It is fully compatible with the GraphQL specification and most of its extensions, and offers type safety and high performance.</p>
<p>You can define a Schema in Rust and procedural macros will automatically generate code for a GraphQL query. This library does not extend Rust's syntax, which means that Rustfmt can be used normally. I value this highly and it is one of the reasons why I developed <code>Async-graphql</code>.</p>
<h2 id="why-do-this"><a class="header" href="#why-do-this">Why do this?</a></h2>
<p>I like GraphQL and Rust. I've been using <code>Juniper</code>, which solves the problem of implementing a GraphQL server with Rust. But Juniper had several problems, the most important of which is that it didn't support async/await at the time. So I decided to make this library for myself.</p>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>Ensure that there is no CPU-heavy process in background!</p>
<pre><code class="language-shell script">cd benchmark
cargo bench
</code></pre>
<p>Now a HTML report is available at <code>benchmark/target/criterion/report</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<h2 id="add-dependency-libraries"><a class="header" href="#add-dependency-libraries">Add dependency libraries</a></h2>
<pre><code class="language-toml">[dependencies]
async-graphql = &quot;4.0&quot;
async-graphql-actix-web = &quot;4.0&quot; # If you need to integrate into actix-web
async-graphql-warp = &quot;4.0&quot; # If you need to integrate into warp
async-graphql-tide = &quot;4.0&quot; # If you need to integrate into tide
</code></pre>
<h2 id="write-a-schema"><a class="header" href="#write-a-schema">Write a Schema</a></h2>
<p>The Schema of a GraphQL contains a required Query, an optional Mutation, and an optional Subscription. These object types are described using the structure of the Rust language. The field of the structure corresponds to the field of the GraphQL object.</p>
<p><code>Async-graphql</code> implements the mapping of common data types to GraphQL types, such as <code>i32</code>, <code>f64</code>, <code>Option&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, etc. Also, you can <a href="custom_scalars.html">extend these base types</a>, which are called scalars in the GraphQL.</p>
<p>Here is a simple example where we provide just one query that returns the sum of <code>a</code> and <code>b</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    /// Returns the sum of a and b
    async fn add(&amp;self, a: i32, b: i32) -&gt; i32 {
        a + b
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="execute-the-query"><a class="header" href="#execute-the-query">Execute the query</a></h2>
<p>In our example, there is only a Query without a Mutation or Subscription, so we create the Schema with <code>EmptyMutation</code> and <code>EmptySubscription</code>, and then call <code>Schema::execute</code> to execute the Query.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">
</span><span class="boring">struct Query;
</span><span class="boring">#[Object]
</span><span class="boring">impl Query {
</span><span class="boring">  async fn version(&amp;self) -&gt; &amp;str { &quot;1.0&quot; }    
</span><span class="boring">}
</span><span class="boring">async fn other() {
</span>let schema = Schema::new(Query, EmptyMutation, EmptySubscription);
let res = schema.execute(&quot;{ add(a: 10, b: 20) }&quot;).await;
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h2 id="output-the-query-results-as-json"><a class="header" href="#output-the-query-results-as-json">Output the query results as JSON</a></h2>
<pre><code class="language-rust ignore">let json = serde_json::to_string(&amp;res);</code></pre>
<h2 id="web-server-integration"><a class="header" href="#web-server-integration">Web server integration</a></h2>
<p>Please refer to <a href="https://github.com/async-graphql/examples">https://github.com/async-graphql/examples</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-system"><a class="header" href="#type-system">Type System</a></h1>
<p><code>Async-graphql</code> implements conversions from GraphQL Objects to Rust structs, and it's easy to use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simpleobject"><a class="header" href="#simpleobject">SimpleObject</a></h1>
<p><code>SimpleObject</code> directly maps all the fields of a struct to GraphQL object.
If you don't require automatic mapping of fields, see <a href="define_complex_object.html">Object</a>.</p>
<p>The example below defines an object <code>MyObject</code> which includes the fields <code>a</code> and <code>b</code>. <code>c</code> will be not mapped to GraphQL as it is labelled as <code>#[graphql(skip)]</code></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

#[derive(SimpleObject)]
struct MyObject {
    /// Value a
    a: i32,

    /// Value b
    b: i32,

    #[graphql(skip)]
    c: i32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="user-defined-resolvers"><a class="header" href="#user-defined-resolvers">User-defined resolvers</a></h2>
<p>Sometimes most of the fields of a GraphQL object simply return the value of the structure member, but a few
fields are calculated. In this case, the <a href="define_complex_object.html">Object</a> macro cannot be used unless you hand-write all the resolvers.</p>
<p>The <code>ComplexObject</code> macro works in conjunction with the <code>SimpleObject</code> macro. The <code>SimpleObject</code> derive macro defines
the non-calculated fields, where as the <code>ComplexObject</code> macro let's you write user-defined resolvers for the calculated fields.</p>
<p>Resolvers added to <code>ComplexObject</code> adhere to the same rules as resolvers of <a href="define_complex_object.html">Object</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(complex)] // NOTE: If you want the `ComplexObject` macro to take effect, this `complex` attribute is required.
struct MyObj {
    a: i32,
    b: i32,
}

#[ComplexObject]
impl MyObj {
    async fn c(&amp;self) -&gt; i32 {
        self.a + self.b
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="generic-simpleobjects"><a class="header" href="#generic-simpleobjects">Generic <code>SimpleObject</code>s</a></h2>
<p>If you want to reuse a <code>SimpleObject</code> for other types, you can define a generic SimpleObject
and specify how its concrete types should be implemented.</p>
<p>In the following example, two <code>SimpleObject</code> types are created:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct SomeType { a: i32 }
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct SomeOtherType { a: i32 }
</span>#[derive(SimpleObject)]
#[graphql(concrete(name = &quot;SomeName&quot;, params(SomeType)))]
#[graphql(concrete(name = &quot;SomeOtherName&quot;, params(SomeOtherType)))]
pub struct SomeGenericObject&lt;T: OutputType&gt; {
    field1: Option&lt;T&gt;,
    field2: String
}
<span class="boring">}</span></code></pre></pre>
<p>Note: Each generic parameter must implement <code>OutputType</code>, as shown above.</p>
<p>The schema generated is:</p>
<pre><code class="language-gql">type SomeName {
  field1: SomeType
  field2: String!
}

type SomeOtherName {
  field1: SomeOtherType
  field2: String!
}
</code></pre>
<p>In your resolver method or field of another object, use as a normal generic type:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct SomeType { a: i32 }
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct SomeOtherType { a: i32 }
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">#[graphql(concrete(name = &quot;SomeName&quot;, params(SomeType)))]
</span><span class="boring">#[graphql(concrete(name = &quot;SomeOtherName&quot;, params(SomeOtherType)))]
</span><span class="boring">pub struct SomeGenericObject&lt;T: OutputType&gt; {
</span><span class="boring">    field1: Option&lt;T&gt;,
</span><span class="boring">    field2: String,
</span><span class="boring">}
</span>#[derive(SimpleObject)]
pub struct YetAnotherObject {
    a: SomeGenericObject&lt;SomeType&gt;,
    b: SomeGenericObject&lt;SomeOtherType&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>You can pass multiple generic types to <code>params()</code>, separated by a comma.</p>
<h2 id="used-for-both-input-and-output"><a class="header" href="#used-for-both-input-and-output">Used for both input and output</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject, InputObject)]
#[graphql(input_name = &quot;MyObjInput&quot;)] // Note: You must use the input_name attribute to define a new name for the input type, otherwise a runtime error will occur.
struct MyObj {
    a: i32,
    b: i32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="flatten-fields"><a class="header" href="#flatten-fields">Flatten fields</a></h2>
<p>You can flatten fields by adding <code>#[graphql(flatten)]</code>, i.e.:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
pub struct ChildObject {
    b: String,
    c: String,
}

#[derive(SimpleObject)]
pub struct ParentObject {
    a: String,
    #[graphql(flatten)]
    child: ChildObject,
}

// Is the same as

#[derive(SimpleObject)]
pub struct Object {
    a: String,
    b: String,
    c: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object"><a class="header" href="#object">Object</a></h1>
<p>Different from <code>SimpleObject</code>, <code>Object</code> must have a resolver defined for each field in its <code>impl</code>.</p>
<p><strong>A resolver function has to be asynchronous. The first argument has to be <code>&amp;self</code>, the second is an optional <code>Context</code> and it is followed by field arguments.</strong></p>
<p>The resolver is used to get the value of the field. For example, you can query a database and return the result. <strong>The return type of the function is the type of the field.</strong> You can also return a <code>async_graphql::Result</code> to return an error if it occurs. The error message will then be sent as query result.</p>
<p>You may need access to global data in your query, for example a database connection pool.
When creating your <code>Schema</code>, you can use <code>SchemaBuilder::data</code> to configure the global data, and <code>Context::data</code> to configure <code>Context</code> data.
The following <code>value_from_db</code> function shows how to retrieve a database connection from <code>Context</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">struct Data { pub name: String }
</span><span class="boring">struct DbConn {}
</span><span class="boring">impl DbConn {
</span><span class="boring">  fn query_something(&amp;self, id: i64) -&gt; std::result::Result&lt;Data, String&gt; { Ok(Data {name:&quot;&quot;.into()})}
</span><span class="boring">}
</span><span class="boring">struct DbPool {}
</span><span class="boring">impl DbPool {
</span><span class="boring">  fn take(&amp;self) -&gt; DbConn { DbConn {} }    
</span><span class="boring">}
</span>use async_graphql::*;

struct MyObject {
    value: i32,
}

#[Object]
impl MyObject {
    async fn value(&amp;self) -&gt; String {
        self.value.to_string()
    }

    async fn value_from_db(
        &amp;self,
        ctx: &amp;Context&lt;'_&gt;,
        #[graphql(desc = &quot;Id of object&quot;)] id: i64
    ) -&gt; Result&lt;String&gt; {
        let conn = ctx.data::&lt;DbPool&gt;()?.take();
        Ok(conn.query_something(id)?.name)
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context"><a class="header" href="#context">Context</a></h1>
<p>The main goal of <code>Context</code> is to acquire global data attached to Schema and also data related to the actual query being processed.</p>
<h2 id="store-data"><a class="header" href="#store-data">Store Data</a></h2>
<p>Inside the <code>Context</code> you can put global data, like environment variables, db connection pool, whatever you may need in every query.</p>
<p>The data must implement <code>Send</code> and <code>Sync</code>.</p>
<p>You can request the data inside a query by just calling <code>ctx.data::&lt;TypeOfYourData&gt;()</code>.</p>
<p><strong>Note that if the return value of resolver function is borrowed from <code>Context</code>, you will need to explicitly state the lifetime of the argument.</strong></p>
<p>The following example shows how to borrow data in <code>Context</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    async fn borrow_from_context_data&lt;'ctx&gt;(
        &amp;self,
        ctx: &amp;Context&lt;'ctx&gt;
    ) -&gt; Result&lt;&amp;'ctx String&gt; {
        ctx.data::&lt;String&gt;()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="schema-data"><a class="header" href="#schema-data">Schema data</a></h3>
<p>You can put data inside the context at the creation of the schema, it's useful for data that do not change, like a connection pool.</p>
<p>An instance of how it would be written inside an application:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(Default,SimpleObject)]
</span><span class="boring">struct Query { version: i32}
</span><span class="boring">struct EnvStruct;
</span><span class="boring">let env_struct = EnvStruct;
</span><span class="boring">struct S3Object;
</span><span class="boring">let s3_storage = S3Object;
</span><span class="boring">struct DBConnection;
</span><span class="boring">let db_core = DBConnection;
</span>let schema = Schema::build(Query::default(), EmptyMutation, EmptySubscription)
    .data(env_struct)
    .data(s3_storage)
    .data(db_core)
    .finish();
<span class="boring">}</span></code></pre></pre>
<h3 id="request-data"><a class="header" href="#request-data">Request data</a></h3>
<p>You can put data inside the context at the execution of the request, it's useful for authentication data for instance.</p>
<p>A little example with a <code>warp</code> route:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">extern crate async_graphql_warp;
</span><span class="boring">extern crate warp;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use warp::{Filter, Reply};
</span><span class="boring">use std::convert::Infallible;
</span><span class="boring">#[derive(Default, SimpleObject)]
</span><span class="boring">struct Query { name: String }
</span><span class="boring">struct AuthInfo { pub token: Option&lt;String&gt; }
</span><span class="boring">let schema = Schema::build(Query::default(), EmptyMutation, EmptySubscription).finish();
</span><span class="boring">let schema_filter = async_graphql_warp::graphql(schema);
</span>let graphql_post = warp::post()
  .and(warp::path(&quot;graphql&quot;))
  .and(warp::header::optional(&quot;Authorization&quot;))
  .and(schema_filter)
  .and_then( |auth: Option&lt;String&gt;, (schema, mut request): (Schema&lt;Query, EmptyMutation, EmptySubscription&gt;, async_graphql::Request)| async move {
    // Do something to get auth data from the header
    let your_auth_data = AuthInfo { token: auth };
    let response = schema
      .execute(
        request
         .data(your_auth_data)
      ).await;

    Ok::&lt;_, Infallible&gt;(async_graphql_warp::GraphQLResponse::from(response))
  });
<span class="boring">}</span></code></pre></pre>
<h2 id="headers"><a class="header" href="#headers">Headers</a></h2>
<p>With the Context you can also insert and appends headers.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">extern crate http;
</span><span class="boring">use ::http::header::ACCESS_CONTROL_ALLOW_ORIGIN;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">struct Query;
</span>#[Object]
impl Query {
    async fn greet(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; String {
        // Headers can be inserted using the `http` constants
        let was_in_headers = ctx.insert_http_header(ACCESS_CONTROL_ALLOW_ORIGIN, &quot;*&quot;);

        // They can also be inserted using &amp;str
        let was_in_headers = ctx.insert_http_header(&quot;Custom-Header&quot;, &quot;1234&quot;);

        // If multiple headers with the same key are `inserted` then the most recent
        // one overwrites the previous. If you want multiple headers for the same key, use
        // `append_http_header` for subsequent headers
        let was_in_headers = ctx.append_http_header(&quot;Custom-Header&quot;, &quot;Hello World&quot;);

        String::from(&quot;Hello world&quot;)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="selection--lookahead"><a class="header" href="#selection--lookahead">Selection / LookAhead</a></h2>
<p>Sometimes you want to know what fields are requested in the subquery to optimize the processing of data. You can read fields across the query with <code>ctx.field()</code> which will give you a <code>SelectionField</code> which will allow you to navigate across the fields and subfields.</p>
<p>If you want to perform a search across the query or the subqueries, you do not have to do this by hand with the <code>SelectionField</code>, you can use the <code>ctx.look_ahead()</code> to perform a selection</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

#[derive(SimpleObject)]
struct Detail {
    c: i32,
    d: i32,
}

#[derive(SimpleObject)]
struct MyObj {
    a: i32,
    b: i32,
    detail: Detail,
}

struct Query;

#[Object]
impl Query {
    async fn obj(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; MyObj {
        if ctx.look_ahead().field(&quot;a&quot;).exists() {
            // This is a query like `obj { a }`
        } else if ctx.look_ahead().field(&quot;detail&quot;).field(&quot;c&quot;).exists() {
            // This is a query like `obj { detail { c } }`
        } else {
            // This query doesn't have `a`
        }
        unimplemented!()
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>Resolve can return a <code>Result</code>, which has the following definition:</p>
<pre><code class="language-rust ignore">type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;</code></pre>
<p>Any <code>Error</code> that implements <code>std::fmt::Display</code> can be converted to <code>Error</code> and you can extend the error message.</p>
<p>The following example shows how to parse an input string to an integer. When parsing fails, it will return an error and attach an error message.
See the <a href="error_extensions.html">Error Extensions</a> section of this book for more details.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use std::num::ParseIntError;
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    async fn parse_with_extensions(&amp;self, input: String) -&gt; Result&lt;i32&gt; {
        Ok(&quot;234a&quot;
            .parse()
            .map_err(|err: ParseIntError| err.extend_with(|_, e| e.set(&quot;code&quot;, 400)))?)
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="errors-in-subscriptions"><a class="header" href="#errors-in-subscriptions">Errors in subscriptions</a></h4>
<p>Errors can be returned from subscription resolvers as well, using a return type of the form:</p>
<pre><code class="language-rust ignore">async fn my_subscription_resolver(&amp;self) -&gt; impl Stream&lt;Item = Result&lt;MyItem, MyError&gt;&gt; { ... }</code></pre>
<p>Note however that the <code>MyError</code> struct must have <code>Clone</code> implemented, due to the restrictions placed by the <code>Subscription</code> macro. One way to accomplish this is by creating a custom error type, with <code>#[derive(Clone)]</code>, as <a href="https://github.com/async-graphql/async-graphql/issues/845#issuecomment-1090933464">seen here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merging-objects"><a class="header" href="#merging-objects">Merging Objects</a></h1>
<p>Usually we can create multiple implementations for the same type in Rust, but due to the limitation of procedural macros, we can not create multiple Object implementations for the same type. For example, the following code will fail to compile.</p>
<pre><code class="language-rust ignore does_not_compile">#[Object]
impl Query {
    async fn users(&amp;self) -&gt; Vec&lt;User&gt; {
        todo!()
    }
}

#[Object]
impl Query {
    async fn movies(&amp;self) -&gt; Vec&lt;Movie&gt; {
        todo!()
    }
}</code></pre>
<p>Instead, the <code>#[derive(MergedObject)]</code> macro allows you to split an object's resolvers across multiple modules or files by merging 2 or more <code>#[Object]</code> implementations into one.</p>
<p><strong>Tip:</strong> Every <code>#[Object]</code> needs a unique name, even in a <code>MergedObject</code>, so make sure to give each object you're merging its own name.</p>
<p><strong>Note:</strong> This works for queries and mutations. For subscriptions, see &quot;Merging Subscriptions&quot; below.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct User { a: i32 }
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct Movie { a: i32 }
</span>#[derive(Default)]
struct UserQuery;

#[Object]
impl UserQuery {
    async fn users(&amp;self) -&gt; Vec&lt;User&gt; {
        todo!()
    }
}

#[derive(Default)]
struct MovieQuery;

#[Object]
impl MovieQuery {
    async fn movies(&amp;self) -&gt; Vec&lt;Movie&gt; {
        todo!()
    }
}

#[derive(MergedObject, Default)]
struct Query(UserQuery, MovieQuery);

let schema = Schema::new(
    Query::default(),
    EmptyMutation,
    EmptySubscription
);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>⚠️ <strong>MergedObject cannot be used in Interface.</strong></p>
</blockquote>
<h1 id="merging-subscriptions"><a class="header" href="#merging-subscriptions">Merging Subscriptions</a></h1>
<p>Along with <code>MergedObject</code>, you can derive <code>MergedSubscription</code> or use <code>#[MergedSubscription]</code> to merge separate <code>#[Subscription]</code> blocks.</p>
<p>Like merging Objects, each subscription block requires a unique name.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use futures_util::stream::{Stream};
</span><span class="boring">#[derive(Default,SimpleObject)]
</span><span class="boring">struct Query { a: i32 }
</span>#[derive(Default)]
struct Subscription1;

#[Subscription]
impl Subscription1 {
    async fn events1(&amp;self) -&gt; impl Stream&lt;Item = i32&gt; {
        futures_util::stream::iter(0..10)
    }
}

#[derive(Default)]
struct Subscription2;

#[Subscription]
impl Subscription2 {
    async fn events2(&amp;self) -&gt; impl Stream&lt;Item = i32&gt; {
        futures_util::stream::iter(10..20)
    }
}

#[derive(MergedSubscription, Default)]
struct Subscription(Subscription1, Subscription2);

let schema = Schema::new(
    Query::default(),
    EmptyMutation,
    Subscription::default()
);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derived-fields"><a class="header" href="#derived-fields">Derived fields</a></h1>
<p>Sometimes two fields have the same query logic, but the output type is different. In <code>async-graphql</code>, you can create a derived field for it.</p>
<p>In the following example, you already have a <code>date_rfc2822</code> field outputting the time format in <code>RFC2822</code> format, and then reuse it to derive a new <code>date_rfc3339</code> field.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate chrono;
</span><span class="boring">use chrono::Utc;
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>struct DateRFC3339(chrono::DateTime&lt;Utc&gt;);
struct DateRFC2822(chrono::DateTime&lt;Utc&gt;);

#[Scalar]
impl ScalarType for DateRFC3339 {
  fn parse(value: Value) -&gt; InputValueResult&lt;Self&gt; { todo!() } 

  fn to_value(&amp;self) -&gt; Value {
    Value::String(self.0.to_rfc3339())
  }
}

#[Scalar]
impl ScalarType for DateRFC2822 {
  fn parse(value: Value) -&gt; InputValueResult&lt;Self&gt; { todo!() } 

  fn to_value(&amp;self) -&gt; Value {
    Value::String(self.0.to_rfc2822())
  }
}

impl From&lt;DateRFC2822&gt; for DateRFC3339 {
    fn from(value: DateRFC2822) -&gt; Self {
      DateRFC3339(value.0)
    }
}

struct Query;

#[Object]
impl Query {
    #[graphql(derived(name = &quot;date_rfc3339&quot;, into = &quot;DateRFC3339&quot;))]
    async fn date_rfc2822(&amp;self, arg: String) -&gt; DateRFC2822 {
        todo!()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It will render a GraphQL like:</p>
<pre><code class="language-graphql">type Query {
	date_rfc2822(arg: String): DateRFC2822!
	date_rfc3339(arg: String): DateRFC3339!
}
</code></pre>
<h2 id="wrapper-types"><a class="header" href="#wrapper-types">Wrapper types</a></h2>
<p>A derived field won't be able to manage everything easily: Rust's <a href="https://doc.rust-lang.org/book/traits.html#rules-for-implementing-traits">orphan rule</a> requires that either the
trait or the type for which you are implementing the trait must be defined in the same crate as the impl, so the following code cannot be compiled:</p>
<pre><code class="language-rust ignore">impl From&lt;Vec&lt;U&gt;&gt; for Vec&lt;T&gt; {
  ...
}</code></pre>
<p>So you wouldn't be able to generate derived fields for existing wrapper type structures like <code>Vec</code> or <code>Option</code>. But when you implement a <code>From&lt;U&gt; for T</code> you should be able to derived a <code>From&lt;Vec&lt;U&gt;&gt; for Vec&lt;T&gt;</code> and a <code>From&lt;Option&lt;U&gt;&gt; for Option&lt;T&gt;</code>.
We included a <code>with</code> parameter to help you define a function to call instead of using the <code>Into</code> trait implementation between wrapper structures.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate serde;
</span><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(Serialize, Deserialize, Clone)]
struct ValueDerived(String);

#[derive(Serialize, Deserialize, Clone)]
struct ValueDerived2(String);

scalar!(ValueDerived);
scalar!(ValueDerived2);

impl From&lt;ValueDerived&gt; for ValueDerived2 {
    fn from(value: ValueDerived) -&gt; Self {
        ValueDerived2(value.0)
    }
}

fn option_to_option&lt;T, U: From&lt;T&gt;&gt;(value: Option&lt;T&gt;) -&gt; Option&lt;U&gt; {
    value.map(|x| x.into())
}

#[derive(SimpleObject)]
struct TestObj {
    #[graphql(derived(owned, name = &quot;value2&quot;, into = &quot;Option&lt;ValueDerived2&gt;&quot;, with = &quot;option_to_option&quot;))]
    pub value1: Option&lt;ValueDerived&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<p>It's easy to define an <code>Enum</code>, here we have an example:</p>
<p><strong>Async-graphql will automatically change the name of each item to GraphQL's CONSTANT_CASE convention. You can use <code>name</code> to rename.</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

/// One of the films in the Star Wars Trilogy
#[derive(Enum, Copy, Clone, Eq, PartialEq)]
pub enum Episode {
    /// Released in 1977.
    NewHope,

    /// Released in 1980.
    Empire,

    /// Released in 1983.
    #[graphql(name=&quot;AAA&quot;)]
    Jedi,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="wrapping-a-remote-enum"><a class="header" href="#wrapping-a-remote-enum">Wrapping a remote enum</a></h2>
<p>Rust's <a href="https://doc.rust-lang.org/book/traits.html#rules-for-implementing-traits">orphan rule</a> requires that either the 
trait or the type for which you are implementing the trait must be defined in the same crate as the impl, so you cannot 
expose remote enumeration types to GraphQL. In order to provide an <code>Enum</code> type, a common workaround is to create a new 
enum that has parity with the existing, remote enum type.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">mod remote_crate { pub enum RemoteEnum { A, B, C } }
</span>use async_graphql::*;

/// Provides parity with a remote enum type
#[derive(Enum, Copy, Clone, Eq, PartialEq)]
pub enum LocalEnum {
    A,
    B,
    C,
}

/// Conversion interface from remote type to our local GraphQL enum type
impl From&lt;remote_crate::RemoteEnum&gt; for LocalEnum {
    fn from(e: remote_crate::RemoteEnum) -&gt; Self {
        match e {
            remote_crate::RemoteEnum::A =&gt; Self::A,
            remote_crate::RemoteEnum::B =&gt; Self::B,
            remote_crate::RemoteEnum::C =&gt; Self::C,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The process is tedious and requires multiple steps to keep the local and remote enums in sync. <code>Async_graphql</code> provides a handy feature to generate the <code>From&lt;remote_crate::RemoteEnum&gt; for LocalEnum</code> as well as an opposite direction of <code>From&lt;LocalEnum&gt; for remote_crate::RemoteEnum</code> via an additional attribute after deriving <code>Enum</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">mod remote_crate { pub enum RemoteEnum { A, B, C } }
</span>#[derive(Enum, Copy, Clone, Eq, PartialEq)]
#[graphql(remote = &quot;remote_crate::RemoteEnum&quot;)]
enum LocalEnum {
    A,
    B,
    C,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interface"><a class="header" href="#interface">Interface</a></h1>
<p><code>Interface</code> is used to abstract <code>Object</code>s with common fields.
<code>Async-graphql</code> implements it as a wrapper.
The wrapper will forward field resolution to the <code>Object</code> that implements this <code>Interface</code>.
Therefore, the <code>Object</code>'s fields' type and arguments must match with the <code>Interface</code>'s.</p>
<p><code>Async-graphql</code> implements auto conversion from <code>Object</code> to <code>Interface</code>, you only need to call <code>Into::into</code>.</p>
<p>Interface field names are transformed to camelCase for the schema definition.
If you need e.g. a snake_cased GraphQL field name, you can use both the <code>name</code> and <code>method</code> attributes.</p>
<ul>
<li>When <code>name</code> and <code>method</code> exist together, <code>name</code> is the GraphQL field name and the <code>method</code> is the resolver function name.</li>
<li>When only <code>name</code> exists, <code>name.to_camel_case()</code> is the GraphQL field name and the <code>name</code> is the resolver function name.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

struct Circle {
    radius: f32,
}

#[Object]
impl Circle {
    async fn area(&amp;self) -&gt; f32 {
        std::f32::consts::PI * self.radius * self.radius
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Circle { radius: self.radius * s }.into()
    }

    #[graphql(name = &quot;short_description&quot;)]
    async fn short_description(&amp;self) -&gt; String {
        &quot;Circle&quot;.to_string()
    }
}

struct Square {
    width: f32,
}

#[Object]
impl Square {
    async fn area(&amp;self) -&gt; f32 {
        self.width * self.width
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Square { width: self.width * s }.into()
    }

    #[graphql(name = &quot;short_description&quot;)]
    async fn short_description(&amp;self) -&gt; String {
        &quot;Square&quot;.to_string()
    }
}

#[derive(Interface)]
#[graphql(
    field(name = &quot;area&quot;, ty = &quot;f32&quot;),
    field(name = &quot;scale&quot;, ty = &quot;Shape&quot;, arg(name = &quot;s&quot;, ty = &quot;f32&quot;)),
    field(name = &quot;short_description&quot;, method = &quot;short_description&quot;, ty = &quot;String&quot;)
)]
enum Shape {
    Circle(Circle),
    Square(Square),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="register-the-interface-manually"><a class="header" href="#register-the-interface-manually">Register the interface manually</a></h2>
<p><code>Async-graphql</code> traverses and registers all directly or indirectly referenced types from <code>Schema</code> in the initialization phase.
If an interface is not referenced, it will not exist in the registry, as in the following example , even if <code>MyObject</code> implements <code>MyInterface</code>,
because <code>MyInterface</code> is not referenced in <code>Schema</code>, the <code>MyInterface</code> type will not exist in the registry.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(Interface)]
#[graphql(
    field(name = &quot;name&quot;, ty = &quot;String&quot;),
)]
enum MyInterface {
    MyObject(MyObject),
}

#[derive(SimpleObject)]
struct MyObject {
    name: String,
}

struct Query;

#[Object]
impl Query {
    async fn obj(&amp;self) -&gt; MyObject {
        todo!()
    }
}

type MySchema = Schema&lt;Query, EmptyMutation, EmptySubscription&gt;;
<span class="boring">}</span></code></pre></pre>
<p>You need to manually register the <code>MyInterface</code> type when constructing the <code>Schema</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(Interface)]
</span><span class="boring">#[graphql(field(name = &quot;name&quot;, ty = &quot;String&quot;))]
</span><span class="boring">enum MyInterface { MyObject(MyObject) }
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct MyObject { name: String, }
</span><span class="boring">struct Query;
</span><span class="boring">#[Object]
</span><span class="boring">impl Query { async fn version(&amp;self) -&gt; &amp;str { &quot;1.0&quot; } }
</span>
Schema::build(Query, EmptyMutation, EmptySubscription)
    .register_output_type::&lt;MyInterface&gt;()
    .finish();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="union"><a class="header" href="#union">Union</a></h1>
<p>The definition of a <code>Union</code> is similar to an <code>Interface</code>, <strong>but with no fields allowed.</strong>.
The implementation is quite similar for <code>Async-graphql</code>; from <code>Async-graphql</code>'s perspective, <code>Union</code> is a subset of <code>Interface</code>.</p>
<p>The following example modified the definition of <code>Interface</code> a little bit and removed fields.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

struct Circle {
    radius: f32,
}

#[Object]
impl Circle {
    async fn area(&amp;self) -&gt; f32 {
        std::f32::consts::PI * self.radius * self.radius
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Circle { radius: self.radius * s }.into()
    }
}

struct Square {
    width: f32,
}

#[Object]
impl Square {
    async fn area(&amp;self) -&gt; f32 {
        self.width * self.width
    }

    async fn scale(&amp;self, s: f32) -&gt; Shape {
        Square { width: self.width * s }.into()
    }
}

#[derive(Union)]
enum Shape {
    Circle(Circle),
    Square(Square),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="flattening-nested-unions"><a class="header" href="#flattening-nested-unions">Flattening nested unions</a></h2>
<p>A restriction in GraphQL is the inability to create a union type out of
other union types. All members must be <code>Object</code>. To support nested
unions, we can &quot;flatten&quot; members that are unions, bringing their members up
into the parent union. This is done by applying <code>#[graphql(flatten)]</code> on each
member we want to flatten.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>#[derive(async_graphql::Union)]
pub enum TopLevelUnion {
    A(A),

    // Will fail to compile unless we flatten the union member
    #[graphql(flatten)]
    B(B),
}

#[derive(async_graphql::SimpleObject)]
pub struct A {
    a: i32,
    // ...
}

#[derive(async_graphql::Union)]
pub enum B {
    C(C),
    D(D),
}

#[derive(async_graphql::SimpleObject)]
pub struct C {
    c: i32,
    // ...
}

#[derive(async_graphql::SimpleObject)]
pub struct D {
    d: i32,
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>The above example transforms the top-level union into this equivalent:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">#[derive(async_graphql::SimpleObject)]
</span><span class="boring">struct A { a: i32 }
</span><span class="boring">#[derive(async_graphql::SimpleObject)]
</span><span class="boring">struct C { c: i32 }
</span><span class="boring">#[derive(async_graphql::SimpleObject)]
</span><span class="boring">struct D { d: i32 }
</span>#[derive(async_graphql::Union)]
pub enum TopLevelUnion {
    A(A),
    C(C),
    D(D),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inputobject"><a class="header" href="#inputobject">InputObject</a></h1>
<p>You can use an <code>Object</code> as an argument, and GraphQL calls it an <code>InputObject</code>.</p>
<p>The definition of <code>InputObject</code> is similar to <a href="define_simple_object.html">SimpleObject</a>, but
<code>SimpleObject</code> can only be used as output and <code>InputObject</code> can only be used as input.</p>
<p>You can add optional <code>#[graphql]</code> attributes to add descriptions or rename the field.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct User { a: i32 }
</span>use async_graphql::*;

#[derive(InputObject)]
struct Coordinate {
    latitude: f64,
    longitude: f64
}

struct Mutation;

#[Object]
impl Mutation {
    async fn users_at_location(&amp;self, coordinate: Coordinate, radius: f64) -&gt; Vec&lt;User&gt; {
        // Writes coordination to database.
        // ...
<span class="boring">      todo!()
</span>    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="generic-inputobjects"><a class="header" href="#generic-inputobjects">Generic <code>InputObject</code>s</a></h2>
<p>If you want to reuse an <code>InputObject</code> for other types, you can define a generic InputObject
and specify how its concrete types should be implemented.</p>
<p>In the following example, two <code>InputObject</code> types are created:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(InputObject)]
</span><span class="boring">struct SomeType { a: i32 }
</span><span class="boring">#[derive(InputObject)]
</span><span class="boring">struct SomeOtherType { a: i32 }
</span>#[derive(InputObject)]
#[graphql(concrete(name = &quot;SomeName&quot;, params(SomeType)))]
#[graphql(concrete(name = &quot;SomeOtherName&quot;, params(SomeOtherType)))]
pub struct SomeGenericInput&lt;T: InputType&gt; {
    field1: Option&lt;T&gt;,
    field2: String
}
<span class="boring">}</span></code></pre></pre>
<p>Note: Each generic parameter must implement <code>InputType</code>, as shown above.</p>
<p>The schema generated is:</p>
<pre><code class="language-gql">input SomeName {
  field1: SomeType
  field2: String!
}

input SomeOtherName {
  field1: SomeOtherType
  field2: String!
}
</code></pre>
<p>In your resolver method or field of another input object, use as a normal generic type:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(InputObject)]
</span><span class="boring">struct SomeType { a: i32 }
</span><span class="boring">#[derive(InputObject)]
</span><span class="boring">struct SomeOtherType { a: i32 }
</span><span class="boring">#[derive(InputObject)]
</span><span class="boring">#[graphql(concrete(name = &quot;SomeName&quot;, params(SomeType)))]
</span><span class="boring">#[graphql(concrete(name = &quot;SomeOtherName&quot;, params(SomeOtherType)))]
</span><span class="boring">pub struct SomeGenericInput&lt;T: InputType&gt; {
</span><span class="boring">    field1: Option&lt;T&gt;,
</span><span class="boring">    field2: String
</span><span class="boring">}
</span>#[derive(InputObject)]
pub struct YetAnotherInput {
    a: SomeGenericInput&lt;SomeType&gt;,
    b: SomeGenericInput&lt;SomeOtherType&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>You can pass multiple generic types to <code>params()</code>, separated by a comma.</p>
<h2 id="redacting-sensitive-data"><a class="header" href="#redacting-sensitive-data">Redacting sensitive data</a></h2>
<p>If any part of your input is considered sensitive and you wish to redact it, you can mark it with <code>secret</code> directive. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(InputObject)]
pub struct CredentialsInput {
    username: String,
    #[graphql(secret)]
    password: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="flattening-fields"><a class="header" href="#flattening-fields">Flattening fields</a></h2>
<p>You can add <code>#[graphql(flatten)]</code> to a field to inline keys from the field type into it's parent. For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(InputObject)]
pub struct ChildInput {
    b: String,
    c: String,
}

#[derive(InputObject)]
pub struct ParentInput {
    a: String,
    #[graphql(flatten)]
    child: ChildInput,
}

// Is the same as

#[derive(InputObject)]
pub struct Input {
    a: String,
    b: String,
    c: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oneofobject"><a class="header" href="#oneofobject">OneofObject</a></h1>
<p>A <code>OneofObject</code> is a special type of <code>InputObject</code>, in which only one of its fields must be set and is not-null.
It is especially useful when you want a user to be able to choose between several potential input types.</p>
<p>This feature is still an <a href="https://github.com/graphql/graphql-spec/pull/825">RFC</a> and therefore not yet officially part of the GraphQL spec, but <code>Async-graphql</code> already supports it!</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct User { a: i32 }
</span>use async_graphql::*;

#[derive(OneofObject)]
enum UserBy {
    Email(String),
    RegistrationNumber(i64),
    Address(Address)
}

#[derive(InputObject)]
struct Address {
    street: String,
    house_number: String,
    city: String,
    zip: String,
}

struct Query {}

#[Object]
impl Query {
    async fn search_users(&amp;self, by: Vec&lt;UserBy&gt;) -&gt; Vec&lt;User&gt; {
        // ... Searches and returns a list of users ...
<span class="boring">        todo!()
</span>    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, a <code>OneofObject</code> is represented by an <code>enum</code> in which each variant contains another <code>InputType</code>. This means that you can use <a href="define_input_object.html"><code>InputObject</code></a> as variant too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-value"><a class="header" href="#default-value">Default value</a></h1>
<p>You can define default values for input value types.
Below are some examples.</p>
<h2 id="object-field"><a class="header" href="#object-field">Object field</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

struct Query;

fn my_default() -&gt; i32 {
    30
}

#[Object]
impl Query {
    // The default value of the value parameter is 0, it will call i32::default()
    async fn test1(&amp;self, #[graphql(default)] value: i32) -&gt; i32 { todo!() }

    // The default value of the value parameter is 10
    async fn test2(&amp;self, #[graphql(default = 10)] value: i32) -&gt; i32 { todo!() }
    
    // The default value of the value parameter uses the return result of the my_default function, the value is 30.
    async fn test3(&amp;self, #[graphql(default_with = &quot;my_default()&quot;)] value: i32) -&gt; i32 { todo!() }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interface-field"><a class="header" href="#interface-field">Interface field</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">fn my_default() -&gt; i32 { 5 }
</span><span class="boring">struct MyObj;
</span><span class="boring">#[Object]
</span><span class="boring">impl MyObj {
</span><span class="boring">   async fn test1(&amp;self, value: i32) -&gt; i32 { todo!() }
</span><span class="boring">   async fn test2(&amp;self, value: i32) -&gt; i32 { todo!() }
</span><span class="boring">   async fn test3(&amp;self, value: i32) -&gt; i32 { todo!() }
</span><span class="boring">}
</span>use async_graphql::*;

#[derive(Interface)]
#[graphql(
    field(name = &quot;test1&quot;, ty = &quot;i32&quot;, arg(name = &quot;value&quot;, ty = &quot;i32&quot;, default)),
    field(name = &quot;test2&quot;, ty = &quot;i32&quot;, arg(name = &quot;value&quot;, ty = &quot;i32&quot;, default = 10)),
    field(name = &quot;test3&quot;, ty = &quot;i32&quot;, arg(name = &quot;value&quot;, ty = &quot;i32&quot;, default_with = &quot;my_default()&quot;)),
)]
enum MyInterface {
    MyObj(MyObj),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="input-object-field"><a class="header" href="#input-object-field">Input object field</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">fn my_default() -&gt; i32 { 5 }
</span>use async_graphql::*;

#[derive(InputObject)]
struct MyInputObject {
    #[graphql(default)]
    value1: i32,

    #[graphql(default = 10)]
    value2: i32,

    #[graphql(default_with = &quot;my_default()&quot;)]
    value3: i32,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema"><a class="header" href="#schema">Schema</a></h1>
<p>After defining the basic types, you need to define a schema to combine them. The schema consists of three types: a query object, a mutation object, and a subscription object, where the mutation object and subscription object are optional.</p>
<p>When the schema is created, <code>Async-graphql</code> will traverse all object graphs and register all types. This means that if a GraphQL object is defined but never referenced, this object will not be exposed in the schema.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-and-mutation"><a class="header" href="#query-and-mutation">Query and Mutation</a></h1>
<h2 id="query-root-object"><a class="header" href="#query-root-object">Query root object</a></h2>
<p>The query root object is a GraphQL object with a definition similar to other objects. Resolver functions for all fields of the query object are executed concurrently.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;
<span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct User { a: i32 }
</span>
struct Query;

#[Object]
impl Query {
    async fn user(&amp;self, username: String) -&gt; Result&lt;Option&lt;User&gt;&gt; {
        // Look up users from the database
<span class="boring">       todo!()
</span>    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="mutation-root-object"><a class="header" href="#mutation-root-object">Mutation root object</a></h2>
<p>The mutation root object is also a GraphQL object, but it executes sequentially. One mutation following from another will only be executed only after the first mutation is completed.</p>
<p>The following mutation root object provides an example of user registration and login:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

struct Mutation;

#[Object]
impl Mutation {
    async fn signup(&amp;self, username: String, password: String) -&gt; Result&lt;bool&gt; {
        // User signup
<span class="boring">       todo!()
</span>    }

    async fn login(&amp;self, username: String, password: String) -&gt; Result&lt;String&gt; {
        // User login (generate token)
<span class="boring">       todo!()
</span>    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subscription"><a class="header" href="#subscription">Subscription</a></h1>
<p>The definition of the subscription root object is slightly different from other root objects. Its resolver function always returns a <a href="https://docs.rs/futures-core/~0.3/futures_core/stream/trait.Stream.html">Stream</a> or <code>Result&lt;Stream&gt;</code>, and the field parameters are usually used as data filtering conditions.</p>
<p>The following example subscribes to an integer stream, which generates one integer per second. The parameter <code>step</code> specifies the integer step size with a default of 1.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">use async_graphql::futures_util::stream::Stream;
</span><span class="boring">use async_graphql::futures_util::StreamExt;
</span><span class="boring">extern crate tokio_stream;
</span><span class="boring">extern crate tokio;
</span>use async_graphql::*;

struct Subscription;

#[Subscription]
impl Subscription {
    async fn integers(&amp;self, #[graphql(default = 1)] step: i32) -&gt; impl Stream&lt;Item = i32&gt; {
        let mut value = 0;
        tokio_stream::wrappers::IntervalStream::new(tokio::time::interval(Duration::from_secs(1)))
            .map(move |_| {
                value += step;
                value
            })
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdl-export"><a class="header" href="#sdl-export">SDL Export</a></h1>
<p>You can export your schema in Schema Definition Language (SDL) by using the <code>Schema::sdl()</code> method.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    async fn add(&amp;self, u: i32, v: i32) -&gt; i32 {
        u + v
    }
}

let schema = Schema::build(Query, EmptyMutation, EmptySubscription).finish();
    
// Print the schema in SDL format
println!(&quot;{}&quot;, &amp;schema.sdl());
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utilities"><a class="header" href="#utilities">Utilities</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-guard"><a class="header" href="#field-guard">Field Guard</a></h1>
<p>You can define a <code>guard</code> for the fields of <code>Object</code>, <code>SimpleObject</code>, <code>ComplexObject</code> and <code>Subscription</code>, it will be executed before calling the resolver function, and an error will be returned if it fails.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(Eq, PartialEq, Copy, Clone)]
enum Role {
    Admin,
    Guest,
}

struct RoleGuard {
    role: Role,
}

impl RoleGuard {
    fn new(role: Role) -&gt; Self {
        Self { role }
    }
}

#[async_trait::async_trait]
impl Guard for RoleGuard {
    async fn check(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;()&gt; {
        if ctx.data_opt::&lt;Role&gt;() == Some(&amp;self.role) {
            Ok(())
        } else {
            Err(&quot;Forbidden&quot;.into())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Use it with the <code>guard</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(Eq, PartialEq, Copy, Clone)]
</span><span class="boring">enum Role { Admin, Guest, }
</span><span class="boring">struct RoleGuard { role: Role, }
</span><span class="boring">impl RoleGuard { fn new(role: Role) -&gt; Self { Self { role } } }
</span><span class="boring">#[async_trait::async_trait]
</span><span class="boring">impl Guard for RoleGuard { async fn check(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;()&gt; { todo!() } }
</span>#[derive(SimpleObject)]
struct Query {
    /// Only allow Admin
    #[graphql(guard = &quot;RoleGuard::new(Role::Admin)&quot;)]
    value1: i32,
    /// Allow Admin or Guest
    #[graphql(guard = &quot;RoleGuard::new(Role::Admin).or(RoleGuard::new(Role::Guest))&quot;)]
    value2: i32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="use-parameter-value"><a class="header" href="#use-parameter-value">Use parameter value</a></h2>
<p>Sometimes guards need to use field parameters, you need to pass the parameter value when creating the guard like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>struct EqGuard {
    expect: i32,
    actual: i32,
}

impl EqGuard {
    fn new(expect: i32, actual: i32) -&gt; Self {
        Self { expect, actual }
    }
}

#[async_trait::async_trait]
impl Guard for EqGuard {
    async fn check(&amp;self, _ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;()&gt; {
        if self.expect != self.actual {
            Err(&quot;Forbidden&quot;.into())
        } else {
            Ok(())
        }
    }
}

struct Query;

#[Object]
impl Query {
    #[graphql(guard = &quot;EqGuard::new(100, value)&quot;)]
    async fn get(&amp;self, value: i32) -&gt; i32 {
        value
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-value-validators"><a class="header" href="#input-value-validators">Input value validators</a></h1>
<p><code>Async-graphql</code> has some common validators built-in, you can use them on the parameters of object fields or on the fields of <code>InputObject</code>.</p>
<ul>
<li><strong>maximum=N</strong> the number cannot be greater than <code>N</code>.</li>
<li><strong>minimum=N</strong> the number cannot be less than <code>N</code>.</li>
<li><strong>multiple_of=N</strong> the number must be a multiple of <code>N</code>.</li>
<li><strong>max_items=N</strong> the length of the list cannot be greater than <code>N</code>.</li>
<li><strong>min_items=N</strong> the length of the list cannot be less than <code>N</code>.</li>
<li><strong>max_length=N</strong> the length of the string cannot be greater than <code>N</code>.</li>
<li><strong>min_length=N</strong> the length of the string cannot be less than <code>N</code>.</li>
<li><strong>chars_max_length=N</strong> the count of the unicode chars cannot be greater than <code>N</code>.</li>
<li><strong>chars_min_length=N</strong> the count of the unicode chars cannot be less than <code>N</code>.</li>
<li><strong>email</strong> is valid email.</li>
<li><strong>url</strong> is valid url.</li>
<li><strong>ip</strong> is valid ip address.</li>
<li><strong>regex=RE</strong> is match for the regex.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    /// The length of the name must be greater than or equal to 5 and less than or equal to 10.
    async fn input(&amp;self, #[graphql(validator(min_length = 5, max_length = 10))] name: String) -&gt; Result&lt;i32&gt; {
<span class="boring">        todo!()
</span>    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="check-every-member-of-the-list"><a class="header" href="#check-every-member-of-the-list">Check every member of the list</a></h2>
<p>You can enable the <code>list</code> attribute, and the validator will check all members in list:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

struct Query;

#[Object]
impl Query {
    async fn input(&amp;self, #[graphql(validator(list, max_length = 10))] names: Vec&lt;String&gt;) -&gt; Result&lt;i32&gt; {
<span class="boring">       todo!()
</span>    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-validator"><a class="header" href="#custom-validator">Custom validator</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>struct MyValidator {
    expect: i32,
}

impl MyValidator {
    pub fn new(n: i32) -&gt; Self {
        MyValidator { expect: n }
    }
}

impl CustomValidator&lt;i32&gt; for MyValidator {
    fn check(&amp;self, value: &amp;i32) -&gt; Result&lt;(), InputValueError&lt;i32&gt;&gt; {
        if *value == self.expect {
            Ok(())
        } else {
            Err(InputValueError::custom(format!(&quot;expect 100, actual {}&quot;, value)))
        }
    }
}

struct Query;

#[Object]
impl Query {
    /// n must be equal to 100
    async fn value(
        &amp;self,
        #[graphql(validator(custom = &quot;MyValidator::new(100)&quot;))] n: i32,
    ) -&gt; i32 {
        n
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cache-control"><a class="header" href="#cache-control">Cache control</a></h1>
<p>Production environments often rely on caching to improve performance.</p>
<p>A GraphQL query will call multiple resolver functions and each resolver can have a different cache definition. Some may cache for a few seconds, some may cache for a few hours, some may be the same for all users, and some may be different for each session.</p>
<p><code>Async-graphql</code> provides a mechanism that allows you to define the cache time and scope for each resolver.</p>
<p>You can define cache parameters on the object or on its fields. The following example shows two uses of cache control parameters.</p>
<p>You can use <code>max_age</code> parameters to control the age of the cache (in seconds), and you can also use <code>public</code> and <code>private</code> to control the scope of the cache. When you do not specify it, the scope will default to <code>public</code>.</p>
<p>when querying multiple resolvers, the results of all cache control parameters will be combined and the <code>max_age</code> minimum value will be taken. If the scope of any object or field is <code>private</code>, the result will be <code>private</code>.</p>
<p>We can use <code>QueryResponse</code> to get a merged cache control result from a query result, and call <code>CacheControl::value</code> to get the corresponding HTTP header.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">struct Query;
</span>#[Object(cache_control(max_age = 60))]
impl Query {
    #[graphql(cache_control(max_age = 30))]
    async fn value1(&amp;self) -&gt; i32 {
        1
    }

    #[graphql(cache_control(private))]
    async fn value2(&amp;self) -&gt; i32 {
        2
    }

    async fn value3(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The following are different queries corresponding to different cache control results:</p>
<pre><code class="language-graphql"># max_age=30
{ value1 }
</code></pre>
<pre><code class="language-graphql"># max_age=30, private
{ value1 value2 }
</code></pre>
<pre><code class="language-graphql"># max_age=60
{ value3 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cursor-connections"><a class="header" href="#cursor-connections">Cursor connections</a></h1>
<p>Relay's cursor connection specification is designed to provide a consistent method for query paging. For more details on the specification see the <a href="https://facebook.github.io/relay/graphql/connections.htm">GraphQL Cursor Connections Specification</a>。</p>
<p>Defining a cursor connection in <code>async-graphql</code> is very simple, you just call the <code>connection::query</code> function and query data in the closure.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;
use async_graphql::types::connection::*;

struct Query;

#[Object]
impl Query {
    async fn numbers(&amp;self,
        after: Option&lt;String&gt;,
        before: Option&lt;String&gt;,
        first: Option&lt;i32&gt;,
        last: Option&lt;i32&gt;,
    ) -&gt; Result&lt;Connection&lt;usize, i32, EmptyFields, EmptyFields&gt;&gt; {
        query(after, before, first, last, |after, before, first, last| async move {
            let mut start = after.map(|after| after + 1).unwrap_or(0);
            let mut end = before.unwrap_or(10000);
            if let Some(first) = first {
                end = (start + first).min(end);
            }
            if let Some(last) = last {
                start = if last &gt; end - start {
                     end
                } else {
                    end - last
                };
            }
            let mut connection = Connection::new(start &gt; 0, end &lt; 10000);
            connection.edges.extend(
                (start..end).into_iter().map(|n|
                    Edge::with_additional_fields(n, n as i32, EmptyFields)
            ));
            Ok::&lt;_, async_graphql::Error&gt;(connection)
        }).await
    }
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-extensions"><a class="header" href="#error-extensions">Error extensions</a></h1>
<p>To quote the <a href="https://spec.graphql.org/June2018/#example-fce18">graphql-spec</a>:</p>
<blockquote>
<p>GraphQL services may provide an additional entry to errors with key extensions.
This entry, if set, must have a map as its value. This entry is reserved for implementer to add
additional information to errors however they see fit, and there are no additional restrictions on
its contents.</p>
</blockquote>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>I would recommend on checking out this <a href="https://github.com/async-graphql/examples/blob/master/actix-web/error-extensions/src/main.rs">async-graphql example</a> as a quickstart.</p>
<h2 id="general-concept"><a class="header" href="#general-concept">General Concept</a></h2>
<p>In <code>async-graphql</code> all user-facing errors are cast to the <code>Error</code> type which by default provides
the error message exposed by <code>std::fmt::Display</code>. However, <code>Error</code> actually provides an additional information that can extend the error.</p>
<p>A resolver looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">struct Query;
</span><span class="boring">#[Object]
</span><span class="boring">impl Query {
</span>async fn parse_with_extensions(&amp;self) -&gt; Result&lt;i32, Error&gt; {
    Err(Error::new(&quot;MyMessage&quot;).extend_with(|_, e| e.set(&quot;details&quot;, &quot;CAN_NOT_FETCH&quot;)))
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>may then return a response like this:</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;MyMessage&quot;,
      &quot;locations&quot;: [ ... ],
      &quot;path&quot;: [ ... ],
      &quot;extensions&quot;: {
        &quot;details&quot;: &quot;CAN_NOT_FETCH&quot;,
      }
    }
  ]
}
</code></pre>
<h2 id="errorextensions"><a class="header" href="#errorextensions">ErrorExtensions</a></h2>
<p>Constructing new <code>Error</code>s by hand quickly becomes tedious. That is why <code>async-graphql</code> provides
two convenience traits for casting your errors to the appropriate <code>Error</code> with
extensions.</p>
<p>The easiest way to provide extensions to any error is by calling <code>extend_with</code> on the error.
This will on the fly convert any error into a <code>Error</code> with the given extension.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">struct Query;
</span>use std::num::ParseIntError;
<span class="boring">#[Object]
</span><span class="boring">impl Query {
</span>async fn parse_with_extensions(&amp;self) -&gt; Result&lt;i32&gt; {
     Ok(&quot;234a&quot;
         .parse()
         .map_err(|err: ParseIntError| err.extend_with(|_err, e| e.set(&quot;code&quot;, 404)))?)
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h3 id="implementing-errorextensions-for-custom-errors"><a class="header" href="#implementing-errorextensions-for-custom-errors">Implementing ErrorExtensions for custom errors.</a></h3>
<p>If you find yourself attaching extensions to your errors all over the place you might want to consider
implementing the trait on your custom error type directly.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">extern crate thiserror;
</span><span class="boring">use async_graphql::*;
</span>#[derive(Debug, thiserror::Error)]
pub enum MyError {
    #[error(&quot;Could not find resource&quot;)]
    NotFound,

    #[error(&quot;ServerError&quot;)]
    ServerError(String),

    #[error(&quot;No Extensions&quot;)]
    ErrorWithoutExtensions,
}

impl ErrorExtensions for MyError {
    // lets define our base extensions
    fn extend(&amp;self) -&gt; Error {
        Error::new(format!(&quot;{}&quot;, self)).extend_with(|err, e| 
            match self {
              MyError::NotFound =&gt; e.set(&quot;code&quot;, &quot;NOT_FOUND&quot;),
              MyError::ServerError(reason) =&gt; e.set(&quot;reason&quot;, reason.clone()),
              MyError::ErrorWithoutExtensions =&gt; {}
          })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This way you only need to call <code>extend</code> on your error to deliver the error message alongside the provided extensions.
Or further extend your error through <code>extend_with</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">extern crate thiserror;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(Debug, thiserror::Error)]
</span><span class="boring">pub enum MyError {
</span><span class="boring">    #[error(&quot;Could not find resource&quot;)]
</span><span class="boring">    NotFound,
</span><span class="boring">
</span><span class="boring">    #[error(&quot;ServerError&quot;)]
</span><span class="boring">    ServerError(String),
</span><span class="boring">
</span><span class="boring">    #[error(&quot;No Extensions&quot;)]
</span><span class="boring">    ErrorWithoutExtensions,
</span><span class="boring">}
</span><span class="boring">struct Query;
</span><span class="boring">#[Object]
</span><span class="boring">impl Query {
</span>async fn parse_with_extensions_result(&amp;self) -&gt; Result&lt;i32&gt; {
    // Err(MyError::NotFound.extend())
    // OR
    Err(MyError::NotFound.extend_with(|_, e| e.set(&quot;on_the_fly&quot;, &quot;some_more_info&quot;)))
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;NotFound&quot;,
      &quot;locations&quot;: [ ... ],
      &quot;path&quot;: [ ... ],
      &quot;extensions&quot;: {
        &quot;code&quot;: &quot;NOT_FOUND&quot;,
        &quot;on_the_fly&quot;: &quot;some_more_info&quot;
      }
    }
  ]
}
</code></pre>
<h2 id="resultext"><a class="header" href="#resultext">ResultExt</a></h2>
<p>This trait enables you to call <code>extend_err</code> directly on results. So the above code becomes less verbose.</p>
<pre><code class="language-rust ignore"><span class="boring">// @todo figure out why this example does not compile!
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;
<span class="boring">struct Query;
</span><span class="boring">#[Object]
</span><span class="boring">impl Query {
</span>async fn parse_with_extensions(&amp;self) -&gt; Result&lt;i32&gt; {
     Ok(&quot;234a&quot;
         .parse()
         .extend_err(|_, e| e.set(&quot;code&quot;, 404))?)
}
<span class="boring">}</span></code></pre>
<h3 id="chained-extensions"><a class="header" href="#chained-extensions">Chained extensions</a></h3>
<p>Since <code>ErrorExtensions</code> and <code>ResultExt</code> are implemented for any type <code>&amp;E where E: std::fmt::Display</code>
we can chain the extension together.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;
<span class="boring">struct Query;
</span><span class="boring">#[Object]
</span><span class="boring">impl Query {
</span>async fn parse_with_extensions(&amp;self) -&gt; Result&lt;i32&gt; {
    match &quot;234a&quot;.parse() {
        Ok(n) =&gt; Ok(n),
        Err(e) =&gt; Err(e
            .extend_with(|_, e| e.set(&quot;code&quot;, 404))
            .extend_with(|_, e| e.set(&quot;details&quot;, &quot;some more info..&quot;))
            // keys may also overwrite previous keys...
            .extend_with(|_, e| e.set(&quot;code&quot;, 500))),
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Expected response:</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;MyMessage&quot;,
      &quot;locations&quot;: [ ... ],
      &quot;path&quot;: [ ... ],
      &quot;extensions&quot;: {
      	&quot;details&quot;: &quot;some more info...&quot;,
        &quot;code&quot;: 500,
      }
    }
  ]
}
</code></pre>
<h3 id="pitfalls"><a class="header" href="#pitfalls">Pitfalls</a></h3>
<p>Rust does not provide stable trait specialization yet.
That is why <code>ErrorExtensions</code> is actually implemented for <code>&amp;E where E: std::fmt::Display</code>
instead of <code>E: std::fmt::Display</code>. Some specialization is provided through
<a href="https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md">Autoref-based stable specialization</a>.
The disadvantage is that the below code does <strong>NOT</strong> compile:</p>
<pre><code class="language-rust ignore does_not_compile">async fn parse_with_extensions_result(&amp;self) -&gt; Result&lt;i32&gt; {
    // the trait `error::ErrorExtensions` is not implemented
    // for `std::num::ParseIntError`
    &quot;234a&quot;.parse().extend_err(|_, e| e.set(&quot;code&quot;, 404))
}</code></pre>
<p>however this does:</p>
<pre><code class="language-rust ignore does_not_compile">async fn parse_with_extensions_result(&amp;self) -&gt; Result&lt;i32&gt; {
    // does work because ErrorExtensions is implemented for &amp;ParseIntError
    &quot;234a&quot;
      .parse()
      .map_err(|ref e: ParseIntError| e.extend_with(|_, e| e.set(&quot;code&quot;, 404)))
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apollo-tracing"><a class="header" href="#apollo-tracing">Apollo Tracing</a></h1>
<p>Apollo Tracing provides performance analysis results for each step of query. This is an extension to <code>Schema</code>, and the performance analysis results are stored in <code>QueryResponse</code>.</p>
<p>To enable the Apollo Tracing extension, add the extension when the <code>Schema</code> is created.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;
use async_graphql::extensions::ApolloTracing;

<span class="boring">struct Query;
</span><span class="boring">#[Object]
</span><span class="boring">impl Query { async fn version(&amp;self) -&gt; &amp;str { &quot;1.0&quot; } }
</span>
let schema = Schema::build(Query, EmptyMutation, EmptySubscription)
    .extension(ApolloTracing) // Enable ApolloTracing extension
    .finish();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-complexity-and-depth"><a class="header" href="#query-complexity-and-depth">Query complexity and depth</a></h1>
<p>⚠️GraphQL provides a powerful way to query your data, but putting great
power in the hands of your API clients also exposes you to a risk of denial 
of service attacks. You can mitigate that risk with <code>Async-graphql</code> by limiting the 
complexity and depth of the queries you allow.</p>
<h2 id="expensive-queries"><a class="header" href="#expensive-queries">Expensive Queries</a></h2>
<p>Consider a schema that allows listing blog posts. Each blog post is also related to other posts.</p>
<pre><code class="language-graphql">type Query {
	posts(count: Int = 10): [Post!]!
}

type Post {
	title: String!
	text: String!
	related(count: Int = 10): [Post!]!
}
</code></pre>
<p>It's not too hard to craft a query that will cause a very large response:</p>
<pre><code class="language-graphql">{
    posts(count: 100) {
        related(count: 100) {
            related(count: 100) {
                related(count: 100) {
                    title
                }
            }
        }
    }
}
</code></pre>
<p>The size of the response increases exponentially with every other level of the <code>related</code> field. Fortunately, <code>Async-graphql</code> provides 
a way to prevent such queries.</p>
<h2 id="limiting-query-depth"><a class="header" href="#limiting-query-depth">Limiting Query depth</a></h2>
<p>The depth is the number of nesting levels of the field, and the following is a query with a depth of <code>3</code>.</p>
<pre><code class="language-graphql">{
    a {
        b {
            c
        }
    }
}
</code></pre>
<p>You can limit the depth when creating <code>Schema</code>. If the query exceeds this limit, an error will occur and the 
message <code>Query is nested too deep</code> will be returned.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">struct Query;
</span><span class="boring">#[Object]
</span><span class="boring">impl Query { async fn version(&amp;self) -&gt; &amp;str { &quot;1.0&quot; } }
</span>let schema = Schema::build(Query, EmptyMutation, EmptySubscription)
    .limit_depth(5) // Limit the maximum depth to 5
    .finish();
<span class="boring">}</span></code></pre></pre>
<h2 id="limiting-query-complexity"><a class="header" href="#limiting-query-complexity">Limiting Query complexity</a></h2>
<p>The complexity is the number of fields in the query. The default complexity of each field is <code>1</code>. Below is a 
query with a complexity of <code>6</code>.</p>
<pre><code class="language-graphql">{
    a b c {
        d {
            e f
        }
    }
}
</code></pre>
<p>You can limit the complexity when creating the <code>Schema</code>. If the query exceeds this limit, an error will occur 
and <code>Query is too complex</code> will be returned.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">struct Query;
</span><span class="boring">#[Object]
</span><span class="boring">impl Query { async fn version(&amp;self) -&gt; &amp;str { &quot;1.0&quot; } }
</span>let schema = Schema::build(Query, EmptyMutation, EmptySubscription)
    .limit_complexity(5) // Limit the maximum complexity to 5
    .finish();
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-complexity-calculation"><a class="header" href="#custom-complexity-calculation">Custom Complexity Calculation</a></h2>
<p>There are two ways to customize the complexity for non-list type and list type fields.</p>
<p>In the following code, the complexity of the <code>value</code> field is <code>5</code>. The complexity of the <code>values</code> field is <code>count * child_complexity</code>, 
<code>child_complexity</code> is a special variable that represents the complexity of the subquery, and <code>count</code> is the parameter of the field,
used to calculate the complexity of the <code>values</code> field, and the type of the return value must be <code>usize</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>struct Query;

#[Object]
impl Query {
    #[graphql(complexity = 5)]
    async fn value(&amp;self) -&gt; i32 {
        todo!()
    }

    #[graphql(complexity = &quot;count * child_complexity&quot;)]
    async fn values(&amp;self, count: usize) -&gt; i32 {
        todo!()
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Note: The complexity calculation is done in the validation phase and not the execution phase,
so you don't have to worry about partial execution of over-limit queries.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hide-content-in-introspection"><a class="header" href="#hide-content-in-introspection">Hide content in introspection</a></h1>
<p>By default, all types and fields are visible in introspection. But maybe you want to hide some content according to different users to avoid unnecessary misunderstandings. You can add the <code>visible</code> attribute to the type or field to do it.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

#[derive(SimpleObject)]
struct MyObj {
    // This field will be visible in introspection.
    a: i32,

    // This field is always hidden in introspection.
    #[graphql(visible = false)]
    b: i32,

    // This field calls the `is_admin` function, which 
    // is visible if the return value is `true`.
    #[graphql(visible = &quot;is_admin&quot;)]
    c: i32,
}

#[derive(Enum, Copy, Clone, Eq, PartialEq)]
enum MyEnum {
    // This item will be visible in introspection.
    A,

    // This item is always hidden in introspection.
    #[graphql(visible = false)]
    B,

    // This item calls the `is_admin` function, which 
    // is visible if the return value is `true`.
    #[graphql(visible = &quot;is_admin&quot;)]
    C,
}

struct IsAdmin(bool);

fn is_admin(ctx: &amp;Context&lt;'_&gt;) -&gt; bool {
    ctx.data_unchecked::&lt;IsAdmin&gt;().0
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions"><a class="header" href="#extensions">Extensions</a></h1>
<p><code>async-graphql</code> has the capability to be extended with extensions without having to modify the original source code. A lot of features can be added this way, and a lot of extensions already exist.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-extensions-are-defined"><a class="header" href="#how-extensions-are-defined">How extensions are defined</a></h1>
<p>An <code>async-graphql</code> extension is defined by implementing the trait <code>Extension</code> associated. The <code>Extension</code> trait allows you to insert custom code to some several steps used to respond to GraphQL's queries through <code>async-graphql</code>. With <code>Extensions</code>, your application can hook into the GraphQL's requests lifecycle to add behaviors about incoming requests or outgoing response.</p>
<p><code>Extensions</code> are a lot like middleware from other frameworks, be careful when using those: when you use an extension <strong>it'll be run for every GraphQL request</strong>.</p>
<p>Across every step, you'll have the <code>ExtensionContext</code> supplied with data about your current request execution. Feel free to check how it's constructed in the code, documentation about it will soon come.</p>
<h2 id="a-word-about-middleware"><a class="header" href="#a-word-about-middleware">A word about middleware</a></h2>
<p>For those who don't know, let's dig deeper into what is a middleware:</p>
<pre><code class="language-rust ignore">async fn middleware(&amp;self, ctx: &amp;ExtensionContext&lt;'_&gt;, next: NextMiddleware&lt;'_&gt;) -&gt; MiddlewareResult {
  // Logic to your middleware.

  /*
   * Final step to your middleware, we call the next function which will trigger
   * the execution of the next middleware. It's like a `callback` in JavaScript.
   */
  next.run(ctx).await
}</code></pre>
<p>As you have seen, a <code>Middleware</code> is only a function calling the next function at the end, but we could also do a middleware with the <code>next.run</code> function at the start. This is where it's becoming tricky: depending on where you put your logic and where is the <code>next.run</code> call, your logic won't have the same execution order.</p>
<p>Depending on your logic code, you'll want to process it before or after the <code>next.run</code> call. If you need more information about middlewares, there are a lot of things on the web.</p>
<h2 id="processing-of-a-query"><a class="header" href="#processing-of-a-query">Processing of a query</a></h2>
<p>There are several steps to go to process a query to completion, you'll be able to create extension based on these hooks.</p>
<h3 id="request"><a class="header" href="#request">request</a></h3>
<p>First, when we receive a request, if it's not a subscription, the first function to be called will be <code>request</code>, it's the first step, it's the function called at the incoming request, and it's also the function which will output the response to the user.</p>
<p>Default implementation for <code>request</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use async_graphql::extensions::*;
</span><span class="boring">struct MyMiddleware;
</span><span class="boring">#[async_trait::async_trait]
</span><span class="boring">impl Extension for MyMiddleware {
</span>async fn request(&amp;self, ctx: &amp;ExtensionContext&lt;'_&gt;, next: NextRequest&lt;'_&gt;) -&gt; Response {
    next.run(ctx).await
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Depending on where you put your logic code, it'll be executed at the beginning or at the end of the query being processed.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use async_graphql::extensions::*;
</span><span class="boring">struct MyMiddleware;
</span><span class="boring">#[async_trait::async_trait]
</span><span class="boring">impl Extension for MyMiddleware {
</span>async fn request(&amp;self, ctx: &amp;ExtensionContext&lt;'_&gt;, next: NextRequest&lt;'_&gt;) -&gt; Response {
    // The code here will be run before the prepare_request is executed.
    let result = next.run(ctx).await;
    // The code after the completion of this future will be after the processing, just before sending the result to the user.
    result
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h3 id="prepare_request"><a class="header" href="#prepare_request">prepare_request</a></h3>
<p>Just after the <code>request</code>, we will have the <code>prepare_request</code> lifecycle, which will be hooked. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use async_graphql::extensions::*;
</span><span class="boring">struct MyMiddleware;
</span><span class="boring">#[async_trait::async_trait]
</span><span class="boring">impl Extension for MyMiddleware {
</span>async fn prepare_request(
    &amp;self,
    ctx: &amp;ExtensionContext&lt;'_&gt;,
    request: Request,
    next: NextPrepareRequest&lt;'_&gt;,
) -&gt; ServerResult&lt;Request&gt; {
    // The code here will be un before the prepare_request is executed, just after the request lifecycle hook.
    let result = next.run(ctx, request).await;
    // The code here will be run just after the prepare_request
    result
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h3 id="parse_query"><a class="header" href="#parse_query">parse_query</a></h3>
<p>The <code>parse_query</code> will create a GraphQL <code>ExecutableDocument</code> on your query, it'll check if the query is valid for the GraphQL Spec. Usually the implemented spec in <code>async-graphql</code> tends to be the last stable one (October2021).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use async_graphql::extensions::*;
</span><span class="boring">use async_graphql::parser::types::ExecutableDocument;
</span><span class="boring">struct MyMiddleware;
</span><span class="boring">#[async_trait::async_trait]
</span><span class="boring">impl Extension for MyMiddleware {
</span>/// Called at parse query.
async fn parse_query(
    &amp;self,
    ctx: &amp;ExtensionContext&lt;'_&gt;,
    // The raw query
    query: &amp;str,
    // The variables
    variables: &amp;Variables,
    next: NextParseQuery&lt;'_&gt;,
) -&gt; ServerResult&lt;ExecutableDocument&gt; {
    next.run(ctx, query, variables).await
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h3 id="validation"><a class="header" href="#validation">validation</a></h3>
<p>The <code>validation</code> step will check (depending on your <code>validation_mode</code>) rules the query should abide to and give the client data about why the query is not valid.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use async_graphql::extensions::*;
</span><span class="boring">struct MyMiddleware;
</span><span class="boring">#[async_trait::async_trait]
</span><span class="boring">impl Extension for MyMiddleware {
</span>/// Called at validation query.
async fn validation(
  &amp;self,
  ctx: &amp;ExtensionContext&lt;'_&gt;,
  next: NextValidation&lt;'_&gt;,
) -&gt; Result&lt;ValidationResult, Vec&lt;ServerError&gt;&gt; {
  next.run(ctx).await
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h3 id="execute"><a class="header" href="#execute">execute</a></h3>
<p>The <code>execution</code> step is a huge one, it'll start the execution of the query by calling each resolver concurrently for a <code>Query</code> and serially for a <code>Mutation</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use async_graphql::extensions::*;
</span><span class="boring">struct MyMiddleware;
</span><span class="boring">#[async_trait::async_trait]
</span><span class="boring">impl Extension for MyMiddleware {
</span>/// Called at execute query.
async fn execute(
    &amp;self,
    ctx: &amp;ExtensionContext&lt;'_&gt;,
    operation_name: Option&lt;&amp;str&gt;,
    next: NextExecute&lt;'_&gt;,
) -&gt; Response {
    // Before starting resolving the whole query
    let result = next.run(ctx, operation_name).await;
    // After resolving the whole query
    result
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h3 id="resolve"><a class="header" href="#resolve">resolve</a></h3>
<p>The <code>resolve</code> step is launched for each field.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use async_graphql::extensions::*;
</span><span class="boring">struct MyMiddleware;
</span><span class="boring">#[async_trait::async_trait]
</span><span class="boring">impl Extension for MyMiddleware { 
</span>/// Called at resolve field.
async fn resolve(
    &amp;self,
    ctx: &amp;ExtensionContext&lt;'_&gt;,
    info: ResolveInfo&lt;'_&gt;,
    next: NextResolve&lt;'_&gt;,
) -&gt; ServerResult&lt;Option&lt;Value&gt;&gt; {
    // Logic before resolving the field
    let result = next.run(ctx, info).await;
    // Logic after resolving the field
    result
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h3 id="subscribe"><a class="header" href="#subscribe">subscribe</a></h3>
<p>The <code>subscribe</code> lifecycle has the same behavior as the <code>request</code> but for a <code>Subscritpion</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use async_graphql::extensions::*;
</span><span class="boring">use futures_util::stream::BoxStream;
</span><span class="boring">struct MyMiddleware;
</span><span class="boring">#[async_trait::async_trait]
</span><span class="boring">impl Extension for MyMiddleware {
</span>/// Called at subscribe request.
fn subscribe&lt;'s&gt;(
    &amp;self,
    ctx: &amp;ExtensionContext&lt;'_&gt;,
    stream: BoxStream&lt;'s, Response&gt;,
    next: NextSubscribe&lt;'_&gt;,
) -&gt; BoxStream&lt;'s, Response&gt; {
    next.run(ctx, stream)
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions-available"><a class="header" href="#extensions-available">Extensions available</a></h1>
<p>There are a lot of available extensions in the <code>async-graphql</code> to empower your GraphQL Server, some of these documentations are documented here.</p>
<h2 id="analyzer"><a class="header" href="#analyzer">Analyzer</a></h2>
<p><em>Available in the repository</em></p>
<p>The <code>analyzer</code> extension will output a field containing <code>complexity</code> and <code>depth</code> in the response extension field of each query.</p>
<h2 id="apollo-persisted-queries"><a class="header" href="#apollo-persisted-queries">Apollo Persisted Queries</a></h2>
<p><em>Available in the repository</em></p>
<p>To improve network performance for large queries, you can enable this Persisted Queries extension. With this extension enabled, each unique query is associated to a unique identifier, so clients can send this identifier instead of the corresponding query string to reduce requests sizes.</p>
<p>This extension doesn't force you to use some cache strategy, you can choose the caching strategy you want, you'll just have to implement the <code>CacheStorage</code> trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[async_trait::async_trait]
pub trait CacheStorage: Send + Sync + Clone + 'static {
    /// Load the query by `key`.
    async fn get(&amp;self, key: String) -&gt; Option&lt;String&gt;;
    /// Save the query by `key`.
    async fn set(&amp;self, key: String, query: String);
}
<span class="boring">}</span></code></pre></pre>
<p>References: <a href="https://www.apollographql.com/docs/react/api/link/persisted-queries/">Apollo doc - Persisted Queries</a></p>
<h2 id="apollo-tracing-1"><a class="header" href="#apollo-tracing-1">Apollo Tracing</a></h2>
<p><em>Available in the repository</em></p>
<p>Apollo Tracing is an extension which includes analytics data for your queries. This extension works to follow the old and now deprecated <a href="https://github.com/apollographql/apollo-tracing">Apollo Tracing Spec</a>. If you want to check the newer Apollo Reporting Protocol, it's implemented by <a href="https://github.com/async-graphql/async_graphql_apollo_studio_extension">async-graphql Apollo studio extension</a> for Apollo Studio.</p>
<h2 id="apollo-studio"><a class="header" href="#apollo-studio">Apollo Studio</a></h2>
<p><em>Available at <a href="https://github.com/async-graphql/async_graphql_apollo_studio_extension">async-graphql/async_graphql_apollo_studio_extension</a></em></p>
<p>Apollo Studio is a cloud platform that helps you build, validate, and secure your organization's graph (description from the official documentation). It's a service allowing you to monitor &amp; work with your team around your GraphQL Schema. <code>async-graphql</code> provides an extension implementing the official <a href="https://www.apollographql.com/docs/studio/setup-analytics/#third-party-support">Apollo Specification</a> available at <a href="https://github.com/async-graphql/async_graphql_apollo_studio_extension">async-graphql-extension-apollo-tracing</a> and <a href="https://crates.io/crates/async-graphql-extension-apollo-tracing">Crates.io</a>.</p>
<h2 id="logger"><a class="header" href="#logger">Logger</a></h2>
<p><em>Available in the repository</em></p>
<p>Logger is a simple extension allowing you to add some logging feature to <code>async-graphql</code>. It's also a good example to learn how to create your own extension. </p>
<h2 id="opentelemetry"><a class="header" href="#opentelemetry">OpenTelemetry</a></h2>
<p><em>Available in the repository</em></p>
<p>OpenTelemetry is an extension providing an integration with the <a href="https://crates.io/crates/opentelemetry">opentelemetry crate</a> to allow your application to capture distributed traces and metrics from <code>async-graphql</code>.</p>
<h2 id="tracing"><a class="header" href="#tracing">Tracing</a></h2>
<p><em>Available in the repository</em></p>
<p>Tracing is a simple extension allowing you to add some tracing feature to <code>async-graphql</code>. A little like the <code>Logger</code> extension. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrations"><a class="header" href="#integrations">Integrations</a></h1>
<p><code>Async-graphql</code> supports several common Rust web servers.</p>
<ul>
<li>Poem <a href="https://crates.io/crates/async-graphql-poem">async-graphql-poem</a></li>
<li>Actix-web <a href="https://crates.io/crates/async-graphql-actix-web">async-graphql-actix-web</a></li>
<li>Warp <a href="https://crates.io/crates/async-graphql-warp">async-graphql-warp</a></li>
<li>Axum <a href="https://crates.io/crates/async-graphql-axum">async-graphql-axum</a></li>
<li>Rocket <a href="https://crates.io/crates/async-graphql-rocket">async-graphql-rocket</a></li>
</ul>
<p><strong>Even if the server you are currently using is not in the above list, it is quite simple to implement similar functionality yourself.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poem"><a class="header" href="#poem">Poem</a></h1>
<h2 id="request-example"><a class="header" href="#request-example">Request example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql_poem;
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">extern crate poem;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(Default, SimpleObject)]
</span><span class="boring">struct Query { a: i32 }
</span><span class="boring">let schema = Schema::build(Query::default(), EmptyMutation, EmptySubscription).finish();
</span>use poem::Route;
use async_graphql_poem::GraphQL;

let app = Route::new()
    .at(&quot;/ws&quot;, GraphQL::new(schema));
<span class="boring">}</span></code></pre></pre>
<h2 id="subscription-example"><a class="header" href="#subscription-example">Subscription example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql_poem;
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">extern crate poem;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(Default, SimpleObject)]
</span><span class="boring">struct Query { a: i32 }
</span><span class="boring">let schema = Schema::build(Query::default(), EmptyMutation, EmptySubscription).finish();
</span>use poem::{get, Route};
use async_graphql_poem::GraphQLSubscription;

let app = Route::new()
    .at(&quot;/ws&quot;, get(GraphQLSubscription::new(schema)));
<span class="boring">}</span></code></pre></pre>
<h2 id="more-examples"><a class="header" href="#more-examples">More examples</a></h2>
<p><a href="https://github.com/async-graphql/examples/tree/master/poem">https://github.com/async-graphql/examples/tree/master/poem</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="warp"><a class="header" href="#warp">Warp</a></h1>
<p>For <code>Async-graphql-warp</code>, two <code>Filter</code> integrations are provided: <code>graphql</code> and <code>graphql_subscription</code>.</p>
<p>The <code>graphql</code> filter is used for execution <code>Query</code> and <code>Mutation</code> requests. It extracts GraphQL request and outputs <code>async_graphql::Schema</code> and <code>async_graphql::Request</code>.
You can combine other filters later, or directly call <code>Schema::execute</code> to execute the query.</p>
<p><code>graphql_subscription</code> is used to implement WebSocket subscriptions. It outputs <code>warp::Reply</code>.</p>
<h2 id="request-example-1"><a class="header" href="#request-example-1">Request example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql_warp;
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">extern crate warp;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use std::convert::Infallible;
</span><span class="boring">use warp::Filter;
</span><span class="boring">struct QueryRoot;
</span><span class="boring">#[Object]
</span><span class="boring">impl QueryRoot { async fn version(&amp;self) -&gt; &amp;str { &quot;1.0&quot; } }
</span><span class="boring">async fn other() {
</span>type MySchema = Schema&lt;QueryRoot, EmptyMutation, EmptySubscription&gt;;

let schema = Schema::new(QueryRoot, EmptyMutation, EmptySubscription);
let filter = async_graphql_warp::graphql(schema).and_then(|(schema, request): (MySchema, async_graphql::Request)| async move {
    // Execute query
    let resp = schema.execute(request).await;

    // Return result
    Ok::&lt;_, Infallible&gt;(async_graphql_warp::GraphQLResponse::from(resp))
});
warp::serve(filter).run(([0, 0, 0, 0], 8000)).await;
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h2 id="subscription-example-1"><a class="header" href="#subscription-example-1">Subscription example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql_warp;
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">extern crate warp;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use futures_util::stream::{Stream, StreamExt};
</span><span class="boring">use std::convert::Infallible;
</span><span class="boring">use warp::Filter;
</span><span class="boring">struct SubscriptionRoot;
</span><span class="boring">#[Subscription]
</span><span class="boring">impl SubscriptionRoot {
</span><span class="boring">  async fn tick(&amp;self) -&gt; impl Stream&lt;Item = i32&gt; {
</span><span class="boring">    futures_util::stream::iter(0..10)
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">struct QueryRoot;
</span><span class="boring">#[Object]
</span><span class="boring">impl QueryRoot { async fn version(&amp;self) -&gt; &amp;str { &quot;1.0&quot; } }
</span><span class="boring">async fn other() {
</span>let schema = Schema::new(QueryRoot, EmptyMutation, SubscriptionRoot);
let filter = async_graphql_warp::graphql_subscription(schema);
warp::serve(filter).run(([0, 0, 0, 0], 8000)).await;
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h2 id="more-examples-1"><a class="header" href="#more-examples-1">More examples</a></h2>
<p><a href="https://github.com/async-graphql/examples/tree/master/warp">https://github.com/async-graphql/examples/tree/master/warp</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actix-web"><a class="header" href="#actix-web">Actix-web</a></h1>
<h2 id="request-example-2"><a class="header" href="#request-example-2">Request example</a></h2>
<p>When you define your <code>actix_web::App</code> you need to pass in the Schema as data. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql_actix_web;
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">extern crate actix_web;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(Default,SimpleObject)]
</span><span class="boring">struct Query { a: i32 }
</span><span class="boring">let schema = Schema::build(Query::default(), EmptyMutation, EmptySubscription).finish();
</span>use actix_web::{web, HttpRequest, HttpResponse};
use async_graphql_actix_web::{GraphQLRequest, GraphQLResponse};
async fn index(
    // Schema now accessible here
    schema: web::Data&lt;Schema&lt;Query, EmptyMutation, EmptySubscription&gt;&gt;,
    request: GraphQLRequest,
) -&gt; web::Json&lt;GraphQLResponse&gt; {
    web::Json(schema.execute(request.into_inner()).await.into())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="subscription-example-2"><a class="header" href="#subscription-example-2">Subscription example</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql_actix_web;
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">extern crate actix_web;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(Default,SimpleObject)]
</span><span class="boring">struct Query { a: i32 }
</span><span class="boring">let schema = Schema::build(Query::default(), EmptyMutation, EmptySubscription).finish();
</span>use actix_web::{web, HttpRequest, HttpResponse};
use async_graphql_actix_web::GraphQLSubscription;
async fn index_ws(
    schema: web::Data&lt;Schema&lt;Query, EmptyMutation, EmptySubscription&gt;&gt;,
    req: HttpRequest,
    payload: web::Payload,
) -&gt; actix_web::Result&lt;HttpResponse&gt; {
    GraphQLSubscription::new(Schema::clone(&amp;*schema)).start(&amp;req, payload)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="more-examples-2"><a class="header" href="#more-examples-2">More examples</a></h2>
<p><a href="https://github.com/async-graphql/examples/tree/master/actix-web">https://github.com/async-graphql/examples/tree/master/actix-web</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced topics</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-scalars"><a class="header" href="#custom-scalars">Custom scalars</a></h1>
<p>In <code>Async-graphql</code> most common scalar types are built in, but you can also create your own scalar types.</p>
<p>Using <code>async-graphql::Scalar</code>, you can add support for a scalar when you implement it. You only need to implement parsing and output functions.</p>
<p>The following example defines a 64-bit integer scalar where its input and output are strings.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span>use async_graphql::*;

struct StringNumber(i64);

#[Scalar]
impl ScalarType for StringNumber {
    fn parse(value: Value) -&gt; InputValueResult&lt;Self&gt; {
        if let Value::String(value) = &amp;value {
            // Parse the integer value
            Ok(value.parse().map(StringNumber)?)
        } else {
            // If the type does not match
            Err(InputValueError::expected_type(value))
        }
    }

    fn to_value(&amp;self) -&gt; Value {
        Value::String(self.0.to_string())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="use-scalar-macro-to-define-scalar"><a class="header" href="#use-scalar-macro-to-define-scalar">Use <code>scalar!</code> macro to define scalar</a></h2>
<p>If your type implemented <code>serde::Serialize</code> and <code>serde::Deserialize</code>, then you can use this macro to define a scalar more simply.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">extern crate serde;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">use std::collections::HashMap;
</span>#[derive(Serialize, Deserialize)]
struct MyValue {
    a: i32,
    b: HashMap&lt;String, i32&gt;,     
}

scalar!(MyValue);

// Rename to `MV`.
// scalar!(MyValue, &quot;MV&quot;);

// Rename to `MV` and add description.
// scalar!(MyValue, &quot;MV&quot;, &quot;This is my value&quot;);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimizing-n1-queries"><a class="header" href="#optimizing-n1-queries">Optimizing N+1 queries</a></h1>
<p>Have you noticed some GraphQL queries end can make hundreds of database queries, often with mostly repeated data? Lets take a look why and how to fix it.</p>
<h2 id="query-resolution"><a class="header" href="#query-resolution">Query Resolution</a></h2>
<p>Imagine if you have a simple query like this:</p>
<pre><code class="language-graphql">query {
  todos {
    users {
      name
    }
  }
}
</code></pre>
<p>and <code>User</code> resolver is like this:</p>
<pre><code class="language-rust ignore">struct User {
    id: u64,
}

#[Object]
impl User {
    async fn name(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;String&gt; {
        let pool = ctx.data_unchecked::&lt;Pool&lt;Postgres&gt;&gt;();
        let (name,): (String,) = sqlx::query_as(&quot;SELECT name FROM user WHERE id = $1&quot;)
            .bind(self.id)
            .fetch_one(pool)
            .await?;
        Ok(name)
    }
}</code></pre>
<p>The query executor will call the <code>Todos</code> resolver which does a <code>select * from todo and return N todos</code>. Then for each
of the todos, concurrently, call the <code>User</code> resolver, <code>SELECT from USER where id = todo.user_id</code>.</p>
<p>eg：</p>
<pre><code class="language-sql">SELECT id, todo, user_id FROM todo
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
SELECT name FROM user WHERE id = $1
</code></pre>
<p>After executing <code>SELECT name FROM user WHERE id = $1</code> many times, and most <code>Todo</code> objects belong to the same user, we
need to optimize these codes!</p>
<h2 id="dataloader"><a class="header" href="#dataloader">Dataloader</a></h2>
<p>We need to group queries and exclude duplicate queries. <code>Dataloader</code> can do this.
<a href="https://github.com/facebook/dataloader">facebook</a> gives a request-scope batch and caching solution.</p>
<p>The following is a simplified example of using <code>DataLoader</code> to optimize queries, there is also a <a href="https://github.com/async-graphql/examples/tree/master/tide/dataloader-postgres">full code example available in GitHub</a>.</p>
<pre><code class="language-rust ignore">use async_graphql::*;
use async_graphql::dataloader::*;
use std::sync::Arc;

struct UserNameLoader {
    pool: sqlx::PgPool,
}

#[async_trait::async_trait]
impl Loader&lt;u64&gt; for UserNameLoader {
    type Value = String;
    type Error = Arc&lt;sqlx::Error&gt;;

    async fn load(&amp;self, keys: &amp;[u64]) -&gt; Result&lt;HashMap&lt;u64, Self::Value&gt;, Self::Error&gt; {
        Ok(sqlx::query_as(&quot;SELECT name FROM user WHERE id = ANY($1)&quot;)
            .bind(keys)
            .fetch(&amp;self.pool)
            .map_ok(|name: String| name)
            .map_err(Arc::new)
            .try_collect().await?)
    }
}

#[derive(SimpleObject)]
#[graphql(complex)]
struct User {
    id: u64,
}

#[ComplexObject]
impl User {
    async fn name(&amp;self, ctx: &amp;Context&lt;'_&gt;) -&gt; Result&lt;String&gt; {
        let loader = ctx.data_unchecked::&lt;DataLoader&lt;UserNameLoader&gt;&gt;();
        let name: Option&lt;String&gt; = loader.load_one(self.id).await?;
        name.ok_or_else(|| &quot;Not found&quot;.into())
    }
}</code></pre>
<p>To expose <code>UserNameLoader</code> in the <code>ctx</code>, you have to register it with the schema, along with a task spawner, e.g. <code>async_std::task::spawn</code>:</p>
<pre><code class="language-rust ignore">let schema = Schema::build(QueryRoot, EmptyMutation, EmptySubscription)
    .data(DataLoader::new(
        UserNameLoader,
        async_std::task::spawn, // or `tokio::spawn`
    ))
    .finish();</code></pre>
<p>In the end, only two SQLs are needed to query the results we want!</p>
<pre><code class="language-sql">SELECT id, todo, user_id FROM todo
SELECT name FROM user WHERE id IN (1, 2, 3, 4)
</code></pre>
<h2 id="implement-multiple-data-types"><a class="header" href="#implement-multiple-data-types">Implement multiple data types</a></h2>
<p>You can implement multiple data types for the same <code>Loader</code>, like this:</p>
<pre><code class="language-rust ignore"><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>struct PostgresLoader {
    pool: sqlx::PgPool,
}

#[async_trait::async_trait]
impl Loader&lt;UserId&gt; for PostgresLoader {
    type Value = User;
    type Error = Arc&lt;sqlx::Error&gt;;

    async fn load(&amp;self, keys: &amp;[UserId]) -&gt; Result&lt;HashMap&lt;UserId, Self::Value&gt;, Self::Error&gt; {
        // Load users from database
    }
}

#[async_trait::async_trait]
impl Loader&lt;TodoId&gt; for PostgresLoader {
    type Value = Todo;
    type Error = sqlx::Error;

    async fn load(&amp;self, keys: &amp;[TodoId]) -&gt; Result&lt;HashMap&lt;TodoId, Self::Value&gt;, Self::Error&gt; {
        // Load todos from database
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-directive"><a class="header" href="#custom-directive">Custom directive</a></h1>
<p>There are two types of directives in GraphQL: executable and type system. Executable directives are used by the client within an operation to modify the behavior (like the built-in <code>@include</code> and <code>@skip</code> directives). Type system directives provide additional information about the types, potentially modifying how the server behaves (like <code>@deprecated</code> and <code>@oneOf</code>). <code>async-graphql</code> allows you to declare both types of custom directives, with different limitations on each. </p>
<h2 id="executable-directives"><a class="header" href="#executable-directives">Executable directives</a></h2>
<p>To create a custom executable directive, you need to implement the <code>CustomDirective</code> trait, and then use the <code>Directive</code> macro to 
generate a factory function that receives the parameters of the directive and returns an instance of the directive.</p>
<p>Currently <code>async-graphql</code> only supports custom executable directives located at <code>FIELD</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>struct ConcatDirective {
    value: String,
}

#[async_trait::async_trait]
impl CustomDirective for ConcatDirective {
    async fn resolve_field(&amp;self, _ctx: &amp;Context&lt;'_&gt;, resolve: ResolveFut&lt;'_&gt;) -&gt; ServerResult&lt;Option&lt;Value&gt;&gt; {
        resolve.await.map(|value| {
            value.map(|value| match value {
                Value::String(str) =&gt; Value::String(str + &amp;self.value),
                _ =&gt; value,
            })
        })
    }
}

#[Directive(location = &quot;Field&quot;)]
fn concat(value: String) -&gt; impl CustomDirective {
    ConcatDirective { value }
}
<span class="boring">}</span></code></pre></pre>
<p>Register the directive when building the schema:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">struct Query;
</span><span class="boring">#[Object]
</span><span class="boring">impl Query { async fn version(&amp;self) -&gt; &amp;str { &quot;1.0&quot; } }
</span><span class="boring">struct ConcatDirective { value: String, }
</span><span class="boring">#[async_trait::async_trait]
</span><span class="boring">impl CustomDirective for ConcatDirective {
</span><span class="boring">  async fn resolve_field(&amp;self, _ctx: &amp;Context&lt;'_&gt;, resolve: ResolveFut&lt;'_&gt;) -&gt; ServerResult&lt;Option&lt;Value&gt;&gt; { todo!() }
</span><span class="boring">}
</span><span class="boring">#[Directive(location = &quot;Field&quot;)]
</span><span class="boring">fn concat(value: String) -&gt; impl CustomDirective { ConcatDirective { value } }
</span>let schema = Schema::build(Query, EmptyMutation, EmptySubscription)
    .directive(concat)
    .finish();
<span class="boring">}</span></code></pre></pre>
<h2 id="type-system-directives"><a class="header" href="#type-system-directives">Type system directives</a></h2>
<p>To create a custom type system directive, you can use the <code>#[TypeDirective]</code> macro on a function:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[TypeDirective(
    location = &quot;FieldDefinition&quot;,
    location = &quot;Object&quot;,
)]
fn testDirective(scope: String, input: u32, opt: Option&lt;u64&gt;) {}
<span class="boring">}</span></code></pre></pre>
<p>Current only the <code>FieldDefinition</code> and <code>Object</code> locations are supported, you can select one or both. After declaring the directive, you can apply it to a relevant location (after importing the function) like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[TypeDirective(
</span><span class="boring">location = &quot;FieldDefinition&quot;,
</span><span class="boring">location = &quot;Object&quot;,
</span><span class="boring">)]
</span><span class="boring">fn testDirective(scope: String, input: u32, opt: Option&lt;u64&gt;) {}
</span>#[derive(SimpleObject)]
#[graphql(
    directive = testDirective::apply(&quot;simple object type&quot;.to_string(), 1, Some(3))
)]
struct SimpleValue {
    #[graphql(
        directive = testDirective::apply(&quot;field and param with \&quot; symbol&quot;.to_string(), 2, Some(3))
    )]
    some_data: String,
}
<span class="boring">}</span></code></pre></pre>
<p>This example produces a schema like this:</p>
<pre><code class="language-graphql">type SimpleValue @testDirective(scope: &quot;simple object type&quot;, input: 1, opt: 3) {
	someData: String! @testDirective(scope: &quot;field and param with \&quot; symbol&quot;, input: 2, opt: 3)
}

directive @testDirective(scope: String!, input: Int!, opt: Int) on FIELD_DEFINITION | OBJECT
</code></pre>
<p>Note: To use a type-system directive with Apollo Federation's <code>@composeDirective</code>, see <a href="./apollo_federation#composeDirective">the federation docs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apollo-federation"><a class="header" href="#apollo-federation">Apollo Federation</a></h1>
<p>Apollo Federation is a GraphQL architecture for combining multiple GraphQL services, or subgraphs, into a single supergraph. You can read more in the <a href="https://www.apollographql.com/docs/apollo-server/federation/">official documentation</a>.</p>
<blockquote>
<p>To see a complete example of federation, check out the <a href="https://github.com/async-graphql/examples/tree/master/federation">federation example</a>. </p>
</blockquote>
<h2 id="enabling-federation-support"><a class="header" href="#enabling-federation-support">Enabling federation support</a></h2>
<p><code>async-graphql</code> supports all the functionality of Apollo Federation v2. Support will be enabled automatically if any <code>#[graphql(entity)]</code> resolvers are found in the schema. To enable it manually, use the <code>enable_federation</code> method on the <code>SchemaBuilder</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">struct Query;
</span><span class="boring">#[Object]
</span><span class="boring">impl Query {
</span><span class="boring">   async fn hello(&amp;self) -&gt; String { &quot;Hello&quot;.to_string() }
</span><span class="boring">}
</span>fn main() {
  let schema = Schema::build(Query, EmptyMutation, EmptySubscription)
    .enable_federation()
    .finish();
  // ... Start your server of choice
}</code></pre></pre>
<p>This will define the <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#link"><code>@link</code> directive</a> on your schema to enable Federation v2.</p>
<h2 id="entities-and-key"><a class="header" href="#entities-and-key">Entities and <code>@key</code></a></h2>
<p><a href="https://www.apollographql.com/docs/federation/entities">Entities</a> are a core feature of federation, they allow multiple subgraphs to contribute fields to the same type. An entity is a GraphQL <code>type</code> with at least one <a href="https://www.apollographql.com/docs/federation/entities#1-define-a-key"><code>@key</code> directive</a>. To create a <a href="https://www.apollographql.com/docs/federation/entities#1-define-a-key"><code>@key</code></a> for a type, create a reference resolver using the <code>#[graphql(entity)]</code> attribute. This resolver should be defined on the <code>Query</code> struct, but will not appear as a field in the schema.</p>
<blockquote>
<p>Even though a reference resolver looks up an individual entity, it is <strong>crucial that you use a <a href="dataloader.html">dataloader</a></strong> in the implementation. The federation router will look up entities in batches, which can quickly lead the N+1 performance issues.</p>
</blockquote>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct User { id: ID }
</span>struct Query;

#[Object]
impl Query {
    #[graphql(entity)]
    async fn find_user_by_id(&amp;self, id: ID) -&gt; User {
        User { id }
    }

    #[graphql(entity)]
    async fn find_user_by_id_with_username(&amp;self, #[graphql(key)] id: ID, username: String) -&gt; User {
        User { id }
    }

    #[graphql(entity)]
    async fn find_user_by_id_and_username(&amp;self, id: ID, username: String) -&gt; User {
        User { id }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Notice the difference between these three lookup functions, which are all looking for the <code>User</code> object.</strong></p>
<ul>
<li>
<p><code>find_user_by_id</code>: Use <code>id</code> to find a <code>User</code> object, the key for <code>User</code> is <code>id</code>.</p>
</li>
<li>
<p><code>find_user_by_id_with_username</code>: Use <code>id</code> to find an <code>User</code> object, the key for <code>User</code> is <code>id</code>, and the <code>username</code> field value of the <code>User</code> object is requested (e.g., via <code>@external</code> and <code>@requires</code>).</p>
</li>
<li>
<p><code>find_user_by_id_and_username</code>: Use <code>id</code> and <code>username</code> to find an <code>User</code> object, the keys for <code>User</code> are <code>id</code> and <code>username</code>.</p>
</li>
</ul>
<p>The resulting schema will look like this:</p>
<pre><code class="language-graphql">type Query {
  # These fields will not be exposed to users, they are only used by the router to resolve entities
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!
}

type User @key(fields: &quot;id&quot;) @key(fields: &quot;id username&quot;) {
  id: ID!
}
</code></pre>
<h3 id="defining-a-compound-primary-key"><a class="header" href="#defining-a-compound-primary-key">Defining a compound primary key</a></h3>
<p>A single primary key can consist of multiple fields, and even nested fields, you can use <code>InputObject</code> to implements a nested primary key.</p>
<p>In the following example, the primary key of the <code>User</code> object is <code>key { a b }</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct User { key: Key }
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct Key { a: i32, b: i32 }
</span>#[derive(InputObject)]
struct NestedKey {
  a: i32,
  b: i32,
}

struct Query;

#[Object]
impl Query {
  #[graphql(entity)]
  async fn find_user_by_key(&amp;self, key: NestedKey) -&gt; User {
    let NestedKey { a, b } = key;
    User { key: Key{a, b} }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>The resulting schema will look like this:</p>
<pre><code class="language-graphql">type Query {
  # These fields will not be exposed to users, they are only used by the router to resolve entities
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!
}

type User @key(fields: &quot;key { a b }&quot;) {
  key: Key!
}

type Key {
  a: Int!
  b: Int!
}
</code></pre>
<h3 id="creating-unresolvable-entities"><a class="header" href="#creating-unresolvable-entities">Creating unresolvable entities</a></h3>
<p>There are certain times when you need to reference an entity, but not add any fields to it. This is particularly useful when you want to link data from separate subgraphs together, but neither subgraph has all the data.</p>
<p>If you wanted to implement the <a href="https://www.apollographql.com/docs/federation/entities/#referencing-an-entity-without-contributing-fields">products and reviews subgraphs example</a> from the Apollo Docs, you would create the following types for the reviews subgraph:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
struct Review {
    product: Product,
    score: u64,
}

#[derive(SimpleObject)]
#[graphql(unresolvable)]
struct Product {
    id: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>This will add the <code>@key(fields: &quot;id&quot;, resolvable: false)</code> directive to the <code>Product</code> type in the reviews subgraph.</p>
<p>For more complex entity keys, such as ones with nested fields in compound keys, you can override the fields in the directive as so:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(unresolvable = &quot;id organization { id }&quot;)]
struct User {
    id: u64,
    organization: Organization,
}

#[derive(SimpleObject)]
struct Organization {
    id: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>However, it is important to note that no validation will be done to check that these fields exist.</p>
<h2 id="shareable"><a class="header" href="#shareable"><code>@shareable</code></a></h2>
<p>Apply the <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#shareable"><code>@shareable</code> directive</a> to a type or field to indicate that multiple subgraphs can resolve it.</p>
<h3 id="shareable-fields"><a class="header" href="#shareable-fields"><code>@shareable</code> fields</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(complex)]
struct Position {
  #[graphql(shareable)]
  x: u64,
}

#[ComplexObject]
impl Position {
  #[graphql(shareable)]
  async fn y(&amp;self) -&gt; u64 {
    0
  }
}
<span class="boring">}</span></code></pre></pre>
<p>The resulting schema will look like this:</p>
<pre><code class="language-graphql">type Position {
  x: Int! @shareable
  y: Int! @shareable
}
</code></pre>
<h3 id="shareable-type"><a class="header" href="#shareable-type"><code>@shareable</code> type</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(shareable)]
struct Position {
  x: u64,
  y: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>The resulting schema will look like this:</p>
<pre><code class="language-graphql">type Position @shareable {
  x: Int!
  y: Int!
}
</code></pre>
<h2 id="inaccessible"><a class="header" href="#inaccessible"><code>@inaccessible</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#inaccessible"><code>@inaccessible</code> directive</a> is used to omit something from the supergraph schema (e.g., if it's not yet added to all subgraphs which share a <code>@shareable</code> type).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(shareable)]
struct Position {
  x: u32,
  y: u32,
  #[graphql(inaccessible)]
  z: u32,
} 
<span class="boring">}</span></code></pre></pre>
<p>Results in:</p>
<pre><code class="language-graphql">type Position @shareable {
  x: Int!
  y: Int!
  z: Int! @inaccessible
}
</code></pre>
<h2 id="override"><a class="header" href="#override"><code>@override</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#override"><code>@override</code> directive</a> is used to take ownership of a field from another subgraph. This is useful for migrating a field from one subgraph to another.</p>
<p>For example, if you add a new &quot;Inventory&quot; subgraph which should take over responsibility for the <code>inStock</code> field currently provided by the &quot;Products&quot; subgraph, you might have something like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
struct Product {
  id: ID,
  #[graphql(override_from = &quot;Products&quot;)]
  in_stock: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>Which results in:</p>
<pre><code class="language-graphql">type Product @key(fields: &quot;id&quot;) {
  id: ID!
  inStock: Boolean! @override(from: &quot;Products&quot;)
}
</code></pre>
<h2 id="external"><a class="header" href="#external"><code>@external</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#external"><code>@external</code> directive</a> is used to indicate that a field is usually provided by another subgraph, but is sometimes required by this subgraph (when combined with <code>@requires</code>) or provided by this subgraph (when combined with <code>@provides</code>).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
struct Product {
  id: ID,
  #[graphql(external)]
  name: String,
  in_stock: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>Results in:</p>
<pre><code class="language-graphql">type Product {
  id: ID!
  name: String! @external
  inStock: Boolean!
}
</code></pre>
<h2 id="provides"><a class="header" href="#provides"><code>@provides</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#provides"><code>@provides</code> directive</a> is used to indicate that a field is provided by this subgraph, but only sometimes.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
struct Product {
    id: ID,
    #[graphql(external)]
    human_name: String,
    in_stock: bool,
}

struct Query;

#[Object]
impl Query {
    /// This operation will provide the `humanName` field on `Product
    #[graphql(provides = &quot;humanName&quot;)]
    async fn out_of_stock_products(&amp;self) -&gt; Vec&lt;Product&gt; {
      vec![Product {
        id: &quot;1&quot;.into(),
        human_name: &quot;My Product&quot;.to_string(),
        in_stock: false,
      }]
    }
    async fn discontinued_products(&amp;self) -&gt; Vec&lt;Product&gt; {
        vec![Product {
            id: &quot;2&quot;.into(),
            human_name: String::new(),  // This is ignored by the router
            in_stock: false,
        }]
    }
    #[graphql(entity)]
    async fn find_product_by_id(&amp;self, id: ID) -&gt; Product {
        Product {
            id,
            human_name: String::new(),  // This is ignored by the router
            in_stock: true,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that the <code>#[graphql(provides)]</code> attribute takes the field name as it appears in the schema, not the Rust field name.</p>
<p>The resulting schema will look like this:</p>
<pre><code class="language-graphql">type Product @key(fields: &quot;id&quot;) {
    id: ID!
    humanName: String! @external
    inStock: Boolean!
}

type Query {
    outOfStockProducts: [Product!]! @provides(fields: &quot;humanName&quot;)
    discontinuedProducts: [Product!]!
}
</code></pre>
<h2 id="requires"><a class="header" href="#requires"><code>@requires</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#requires"><code>@requires</code> directive</a> is used to indicate that an <code>@external</code> field is required for this subgraph to resolve some other field(s). If our <code>shippingEstimate</code> field requires the <code>size</code> and <code>weightInPounts</code> fields, then we might want a subgraph entity which looks like this:</p>
<pre><code class="language-graphql">type Product @key(fields: &quot;id&quot;) {
  id: ID!
  size: Int! @external
  weightInPounds: Int! @external
  shippingEstimate: String! @requires(fields: &quot;size weightInPounds&quot;)
}
</code></pre>
<p>In order to implement this in Rust, we can use the <code>#[graphql(requires)]</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(complex)]
struct Product {
  id: ID,
  #[graphql(external)]
  size: u32,
  #[graphql(external)]
  weight_in_pounds: u32,
}

#[ComplexObject]
impl Product {
  #[graphql(requires = &quot;size weightInPounds&quot;)]
  async fn shipping_estimate(&amp;self) -&gt; String {
    let price = self.size * self.weight_in_pounds;
    format!(&quot;${}&quot;, price)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that we use the GraphQL field name <code>weightInPounds</code>, not the Rust field name <code>weight_in_pounds</code> in <code>requires</code>. To populate those external fields, we add them as arguments in the entity resolver:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">struct Product {
</span><span class="boring">    id: ID,
</span><span class="boring">    #[graphql(external)]
</span><span class="boring">    size: u32,
</span><span class="boring">    #[graphql(external)]
</span><span class="boring">    weight_in_pounds: u32,
</span><span class="boring">}
</span><span class="boring">struct Query;
</span>#[Object]
impl Query {
  #[graphql(entity)]
  async fn find_product_by_id(
    &amp;self, 
    #[graphql(key)] id: ID, 
    size: Option&lt;u32&gt;, 
    weight_in_pounds: Option&lt;u32&gt;
  ) -&gt; Product {
    Product {
      id,
      size: size.unwrap_or_default(),
      weight_in_pounds: weight_in_pounds.unwrap_or_default(),
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>The inputs are <code>Option&lt;&gt;</code> even though the fields are required. This is because the external fields are <em>only</em> passed to the subgraph when the field(s) that require them are being selected. If the <code>shippingEstimate</code> field is not selected, then the <code>size</code> and <code>weightInPounds</code> fields will not be passed to the subgraph. <strong>Always use optional types for external fields.</strong></p>
<p>We have to put <em>something</em> in place for <code>size</code> and <code>weight_in_pounds</code> as they are still required fields on the type, so we use <code>unwrap_or_default()</code> to provide a default value. This looks a little funny, as we're populating the fields with nonsense values, but we have confidence that they will not be needed if they were not provided.  <strong>Make sure to use <code>@requires</code> if you are consuming <code>@external</code> fields, or your code will be wrong.</strong></p>
<h3 id="nested-requires"><a class="header" href="#nested-requires">Nested <code>@requires</code></a></h3>
<p>A case where the <code>@requires</code> directive can be confusing is when there are nested entities. For example, if we had an <code>Order</code> type which contained a <code>Product</code>, then we would need an entity resolver like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span><span class="boring">#[derive(SimpleObject)]
</span><span class="boring">pub struct Order { id: ID }
</span><span class="boring">struct Query;
</span>#[Object]
impl Query {
  #[graphql(entity)]
  async fn find_order_by_id(&amp;self, id: ID) -&gt; Option&lt;Order&gt; {
      Some(Order { id })
  }
}
<span class="boring">}</span></code></pre></pre>
<p>There are no inputs on this entity resolver, so how do we populate the <code>size</code> and <code>weight_in_pounds</code> fields on <code>Product</code> if a user has a query like <code>order { product { shippingEstimate } }</code>? The supergraph implementation will solve this for us by calling the <code>find_product_by_id</code> separately for any fields which have a <code>@requires</code> directive, so the subgraph code does not need to worry about how entities relate.</p>
<h2 id="tag"><a class="header" href="#tag"><code>@tag</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federated-types/federated-directives#tag"><code>@tag</code> directive</a> is used to add metadata to a schema location for features like <a href="https://www.apollographql.com/docs/studio/contracts/">contracts</a>. To add a tag like this:</p>
<pre><code class="language-graphql">type User @tag(name: &quot;team-accounts&quot;) {
  id: String!
  name: String!
}
</code></pre>
<p>You can write code like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[derive(SimpleObject)]
#[graphql(tag = &quot;team-accounts&quot;)]
struct User {
  id: ID,
  name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="composedirective"><a class="header" href="#composedirective"><code>@composeDirective</code></a></h2>
<p>The <a href="https://www.apollographql.com/docs/federation/federation-spec/#composedirective"><code>@composeDirective</code> directive</a> is used to add a custom type system directive to the supergraph schema. Without <code>@composeDirective</code>, and <a href="./custom_directive#type-system-directives">custom type system directives</a> are omitted from the composed supergraph schema. To include a custom type system directive as a composed directive, just add the <code>composable</code> attribute to the <code>#[TypeDirective]</code> macro:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use async_graphql::*;
</span>#[TypeDirective(
    location = &quot;Object&quot;,
    composable = &quot;https://custom.spec.dev/extension/v1.0&quot;,
)]
fn custom() {}
<span class="boring">}</span></code></pre></pre>
<p>In addition to the <a href="./custom_directive#type-system-directives">normal type system directive behavior</a>, this will add the following bits to the output schema:</p>
<pre><code class="language-graphql">extend schema @link(
	url: &quot;https://custom.spec.dev/extension/v1.0&quot;
	import: [&quot;@custom&quot;]
)
	@composeDirective(name: &quot;@custom&quot;)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
